------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm LEVEL 1 PASS 2
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; VCS.H
      4  10000 ????						; Version 1.05, 13/November/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_VCS =	105
      7  10000 ????
      8  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines hardware registers and memory mapping for the
     13  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  10000 ????						; with your views.  Please contribute, if you think you can improve this
     21  10000 ????						; file!
     22  10000 ????						;
     23  10000 ????						; Latest Revisions...
     24  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  10000 ????						;			    This will allow conditional code to verify VCS.H being
     27  10000 ????						;			    used for code assembly.
     28  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  10000 ????						;			 readability issue, and binary compatibility with disassembled
     32  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  10000 ????						;			 which was broken by the use of segments in this file, as
     35  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  10000 ????						;						   it is safe to leave it undefined, and the base address will
     40  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  10000 ????						;			  - register definitions are now generated through assignment
     43  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  10000 ????						;			    address architecture.
     45  10000 ????						; 1.0	22/MAR/2003		Initial release
     46  10000 ????
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????
     50  10000 ????						; TIA_BASE_ADDRESS
     51  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  10000 ????						; Normally 0, the base address should (externally, before including this file)
     53  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  10000 ????						; < $40 as a bankswitch.
     56  10000 ????
     57  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     58  10000 ????			   -TIA_BASE_ADDRESS =	0
     59  10000 ????				       ENDIF
     60  10000 ????
     61  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  10000 ????						; *OR* by declaring the label before including this file, eg:
     64  10000 ????						; TIA_BASE_ADDRESS = $40
     65  10000 ????						;   include "vcs.h"
     66  10000 ????
     67  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  10000 ????						; for the mirrored ROM hardware registers.
     70  10000 ????
     71  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  10000 ????
     75  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     76  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  10000 ????				       ENDIF
     78  10000 ????
     79  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  10000 ????				       ENDIF
     82  10000 ????
     83  10000 ????						;-------------------------------------------------------------------------------
     84  10000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  10000 ????				       SEG
    201  10000 ????
    202  10000 ????						; EOF
------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  10000 ????				       include	"macro.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; MACRO.H
      4  10000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_MACRO =	105
      7  10000 ????
      8  10000 ????						;
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  10000 ????						; It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  10000 ????						; contents, or would like to add something, please write to me
     19  10000 ????						; (atari2600@taswegian.com) with your contribution.
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						;
     23  10000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  10000 ????						;
     28  10000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  10000 ????						;
     30  10000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  10000 ????						;			   (standardised macro for vertical synch code)
     32  10000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  10000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  10000 ????						; 1.0	22/MAR/2003		Initial release
     35  10000 ????
     36  10000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  10000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  10000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  10000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  10000 ????						;   registers and require them to be defined first).
     41  10000 ????
     42  10000 ????						; Available macros...
     43  10000 ????						;   SLEEP n		 - sleep for n cycles
     44  10000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  10000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????						; SLEEP duration
     50  10000 ????						; Original author: Thomas Jentzsch
     51  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  10000 ????						; useful for code where precise timing is required.
     53  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  10000 ????
     57  10000 ????				       MAC	sleep
     58  10000 ????			    .CYCLES    SET	{1}
     59  10000 ????
     60  10000 ????				       IF	.CYCLES < 2
     61  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  10000 ????				       ERR
     63  10000 ????				       ENDIF
     64  10000 ????
     65  10000 ????				       IF	.CYCLES & 1
     66  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     67  10000 ????				       nop	0
     68  10000 ????				       ELSE
     69  10000 ????				       bit	VSYNC
     70  10000 ????				       ENDIF
     71  10000 ????			    .CYCLES    SET	.CYCLES - 3
     72  10000 ????				       ENDIF
     73  10000 ????
     74  10000 ????				       REPEAT	.CYCLES / 2
     75  10000 ????				       nop
     76  10000 ????				       REPEND
     77  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     78  10000 ????
     79  10000 ????						;-------------------------------------------------------------------------------
     80  10000 ????						; VERTICAL_SYNC
     81  10000 ????						; Original author: Manuel Polik
     82  10000 ????						; Inserts the code required for a proper 3 scannline 
     83  10000 ????						; vertical sync sequence
     84  10000 ????						;
     85  10000 ????						; Note: Alters the accumulator
     86  10000 ????						;
     87  10000 ????						; IN:
     88  10000 ????						; OUT: A = 1
     89  10000 ????
     90  10000 ????				       MAC	vertical_sync
     91  10000 ????				       LDA	#$02	; A = VSYNC enable
     92  10000 ????				       STA	WSYNC	; Finish current line
     93  10000 ????				       STA	VSYNC	; Start vertical sync
     94  10000 ????				       STA	WSYNC	; 1st line vertical sync
     95  10000 ????				       STA	WSYNC	; 2nd line vertical sync
     96  10000 ????				       LSR		; A = VSYNC disable
     97  10000 ????				       STA	WSYNC	; 3rd line vertical sync
     98  10000 ????				       STA	VSYNC	; Stop vertical sync
     99  10000 ????				       ENDM
    100  10000 ????
    101  10000 ????						;-------------------------------------------------------------------------------
    102  10000 ????						; CLEAN_START
    103  10000 ????						; Original author: Andrew Davie
    104  10000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  10000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  10000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  10000 ????						; Use as very first section of code on boot (ie: at reset)
    108  10000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  10000 ????
    110  10000 ????				       MAC	clean_start
    111  10000 ????				       sei
    112  10000 ????				       cld
    113  10000 ????
    114  10000 ????				       ldx	#0
    115  10000 ????				       txa
    116  10000 ????				       tay
    117  10000 ????			    .CLEAR_STACK dex
    118  10000 ????				       txs
    119  10000 ????				       pha
    120  10000 ????				       bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  10000 ????
    122  10000 ????				       ENDM
    123  10000 ????
    124  10000 ????						;-------------------------------------------------------
    125  10000 ????						; SET_POINTER
    126  10000 ????						; Original author: Manuel Rotschkar
    127  10000 ????						;
    128  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  10000 ????						;
    130  10000 ????						; Usage: SET_POINTER pointer, address
    131  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  10000 ????						;
    133  10000 ????						; Note: Alters the accumulator, NZ flags
    134  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  10000 ????						; IN 2: absolute address
    136  10000 ????
    137  10000 ????				       MAC	set_pointer
    138  10000 ????			    .POINTER   SET	{1}
    139  10000 ????			    .ADDRESS   SET	{2}
    140  10000 ????
    141  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  10000 ????				       STA	.POINTER	; Store in pointer
    143  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    144  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    145  10000 ????
    146  10000 ????				       ENDM
    147  10000 ????
    148  10000 ????						; EOF
------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  10000 ????				       include	"multisprite.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????		00 80	    missile0x  =	$80
      4  10000 ????		00 81	    missile1x  =	$81
      5  10000 ????		00 82	    ballx      =	$82
      6  10000 ????
      7  10000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  10000 ????
      9  10000 ????		00 83	    SpriteIndex =	$83
     10  10000 ????
     11  10000 ????		00 84	    player0x   =	$84
     12  10000 ????		00 85	    NewSpriteX =	$85	;		X position
     13  10000 ????		00 85	    player1x   =	$85
     14  10000 ????		00 86	    player2x   =	$86
     15  10000 ????		00 87	    player3x   =	$87
     16  10000 ????		00 88	    player4x   =	$88
     17  10000 ????		00 89	    player5x   =	$89
     18  10000 ????
     19  10000 ????		00 8a	    objecty    =	$8A
     20  10000 ????		00 8a	    missile0y  =	$8A
     21  10000 ????		00 8b	    missile1y  =	$8B
     22  10000 ????		00 8c	    bally      =	$8C
     23  10000 ????
     24  10000 ????		00 8d	    player0y   =	$8D
     25  10000 ????		00 8e	    NewSpriteY =	$8E	;		Y position
     26  10000 ????		00 8e	    player1y   =	$8E
     27  10000 ????		00 8f	    player2y   =	$8F
     28  10000 ????		00 90	    player3y   =	$90
     29  10000 ????		00 91	    player4y   =	$91
     30  10000 ????		00 92	    player5y   =	$92
     31  10000 ????
     32  10000 ????		00 93	    NewNUSIZ   =	$93
     33  10000 ????		00 93	    _NUSIZ1    =	$93
     34  10000 ????		00 94	    NUSIZ2     =	$94
     35  10000 ????		00 95	    NUSIZ3     =	$95
     36  10000 ????		00 96	    NUSIZ4     =	$96
     37  10000 ????		00 97	    NUSIZ5     =	$97
     38  10000 ????
     39  10000 ????		00 98	    NewCOLUP1  =	$98
     40  10000 ????		00 98	    _COLUP1    =	$98
     41  10000 ????		00 99	    COLUP2     =	$99
     42  10000 ????		00 9a	    COLUP3     =	$9A
     43  10000 ????		00 9b	    COLUP4     =	$9B
     44  10000 ????		00 9c	    COLUP5     =	$9C
     45  10000 ????
     46  10000 ????		00 9d	    SpriteGfxIndex =	$9D
     47  10000 ????
     48  10000 ????		00 a2	    player0pointer =	$A2
     49  10000 ????		00 a2	    player0pointerlo =	$A2
     50  10000 ????		00 a3	    player0pointerhi =	$A3
     51  10000 ????
     52  10000 ????						;P0Top = temp5
     53  10000 ????		00 cf	    P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  10000 ????		00 a4	    P0Bottom   =	$A4
     55  10000 ????		00 a5	    P1Bottom   =	$A5
     56  10000 ????
     57  10000 ????		00 a6	    player1pointerlo =	$A6
     58  10000 ????		00 a7	    player2pointerlo =	$A7
     59  10000 ????		00 a8	    player3pointerlo =	$A8
     60  10000 ????		00 a9	    player4pointerlo =	$A9
     61  10000 ????		00 aa	    player5pointerlo =	$AA
     62  10000 ????
     63  10000 ????		00 ab	    player1pointerhi =	$AB
     64  10000 ????		00 ac	    player2pointerhi =	$AC
     65  10000 ????		00 ad	    player3pointerhi =	$AD
     66  10000 ????		00 ae	    player4pointerhi =	$AE
     67  10000 ????		00 af	    player5pointerhi =	$AF
     68  10000 ????
     69  10000 ????		00 b0	    player0height =	$B0
     70  10000 ????		00 b1	    spriteheight =	$B1	; heights of multiplexed player sprite
     71  10000 ????		00 b1	    player1height =	$B1
     72  10000 ????		00 b2	    player2height =	$B2
     73  10000 ????		00 b3	    player3height =	$B3
     74  10000 ????		00 b4	    player4height =	$B4
     75  10000 ????		00 b5	    player5height =	$B5
     76  10000 ????
     77  10000 ????		00 b6	    PF1temp1   =	$B6
     78  10000 ????		00 b7	    PF1temp2   =	$B7
     79  10000 ????		00 b8	    PF2temp1   =	$B8
     80  10000 ????		00 b9	    PF2temp2   =	$B9
     81  10000 ????
     82  10000 ????		00 ba	    pfpixelheight =	$BA
     83  10000 ????
     84  10000 ????						; playfield is now a pointer to graphics
     85  10000 ????		00 bb	    playfield  =	$BB
     86  10000 ????		00 bb	    PF1pointer =	$BB
     87  10000 ????
     88  10000 ????		00 bd	    PF2pointer =	$BD
     89  10000 ????
     90  10000 ????		00 bf	    statusbarlength =	$BF
     91  10000 ????		00 bf	    aux3       =	$BF
     92  10000 ????
     93  10000 ????		00 c0	    lifecolor  =	$C0
     94  10000 ????		00 c0	    pfscorecolor =	$C0
     95  10000 ????		00 c0	    aux4       =	$C0
     96  10000 ????
     97  10000 ????						;P1display = temp2 ; temp2 and temp3
     98  10000 ????		00 cc	    P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  10000 ????		00 c1	    lifepointer =	$c1
    100  10000 ????		00 c2	    lives      =	$c2
    101  10000 ????		00 c1	    pfscore1   =	$c1
    102  10000 ????		00 c2	    pfscore2   =	$c2
    103  10000 ????		00 c1	    aux5       =	$c1
    104  10000 ????		00 c2	    aux6       =	$c2
    105  10000 ????
    106  10000 ????		00 c3	    playfieldpos =	$C3
    107  10000 ????
    108  10000 ????						;RepoLine = temp4
    109  10000 ????		00 ce	    RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  10000 ????
    111  10000 ????		00 c4	    pfheight   =	$C4
    112  10000 ????		00 c5	    scorepointers =	$C5
    113  10000 ????
    114  10000 ????		00 cb	    temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  10000 ????		00 cc	    temp2      =	$CC	;are obliterated when drawscreen is called.
    116  10000 ????		00 cd	    temp3      =	$CD
    117  10000 ????		00 ce	    temp4      =	$CE
    118  10000 ????		00 cf	    temp5      =	$CF
    119  10000 ????		00 d0	    temp6      =	$D0
    120  10000 ????		00 d1	    temp7      =	$D1	; This is used to aid in bankswitching
    121  10000 ????
    122  10000 ????		00 d2	    score      =	$D2
    123  10000 ????		00 d5	    scorecolor =	$D5	;need to find other places for these, possibly...
    124  10000 ????		00 d6	    rand       =	$D6
    125  10000 ????
    126  10000 ????
    127  10000 ????
    128  10000 ????		00 d7	    A	       =	$d7
    129  10000 ????		00 d7	    a	       =	$d7
    130  10000 ????		00 d8	    B	       =	$d8
    131  10000 ????		00 d8	    b	       =	$d8
    132  10000 ????		00 d9	    C	       =	$d9
    133  10000 ????		00 d9	    c	       =	$d9
    134  10000 ????		00 da	    D	       =	$da
    135  10000 ????		00 da	    d	       =	$da
    136  10000 ????		00 db	    E	       =	$db
    137  10000 ????		00 db	    e	       =	$db
    138  10000 ????		00 dc	    F	       =	$dc
    139  10000 ????		00 dc	    f	       =	$dc
    140  10000 ????		00 dd	    G	       =	$dd
    141  10000 ????		00 dd	    g	       =	$dd
    142  10000 ????		00 de	    H	       =	$de
    143  10000 ????		00 de	    h	       =	$de
    144  10000 ????		00 df	    I	       =	$df
    145  10000 ????		00 df	    i	       =	$df
    146  10000 ????		00 e0	    J	       =	$e0
    147  10000 ????		00 e0	    j	       =	$e0
    148  10000 ????		00 e1	    K	       =	$e1
    149  10000 ????		00 e1	    k	       =	$e1
    150  10000 ????		00 e2	    L	       =	$e2
    151  10000 ????		00 e2	    l	       =	$e2
    152  10000 ????		00 e3	    M	       =	$e3
    153  10000 ????		00 e3	    m	       =	$e3
    154  10000 ????		00 e4	    N	       =	$e4
    155  10000 ????		00 e4	    n	       =	$e4
    156  10000 ????		00 e5	    O	       =	$e5
    157  10000 ????		00 e5	    o	       =	$e5
    158  10000 ????		00 e6	    P	       =	$e6
    159  10000 ????		00 e6	    p	       =	$e6
    160  10000 ????		00 e7	    Q	       =	$e7
    161  10000 ????		00 e7	    q	       =	$e7
    162  10000 ????		00 e8	    R	       =	$e8
    163  10000 ????		00 e8	    r	       =	$e8
    164  10000 ????		00 e9	    S	       =	$e9
    165  10000 ????		00 e9	    s	       =	$e9
    166  10000 ????		00 ea	    T	       =	$ea
    167  10000 ????		00 ea	    t	       =	$ea
    168  10000 ????		00 eb	    U	       =	$eb
    169  10000 ????		00 eb	    u	       =	$eb
    170  10000 ????		00 ec	    V	       =	$ec
    171  10000 ????		00 ec	    v	       =	$ec
    172  10000 ????		00 ed	    W	       =	$ed
    173  10000 ????		00 ed	    w	       =	$ed
    174  10000 ????		00 ee	    X	       =	$ee
    175  10000 ????		00 ee	    x	       =	$ee
    176  10000 ????		00 ef	    Y	       =	$ef
    177  10000 ????		00 ef	    y	       =	$ef
    178  10000 ????		00 f0	    Z	       =	$f0
    179  10000 ????		00 f0	    z	       =	$f0
    180  10000 ????
    181  10000 ????		00 f1	    spritesort =	$f1	; helps with flickersort
    182  10000 ????		00 f2	    spritesort2 =	$f2	; helps with flickersort
    183  10000 ????		00 f3	    spritesort3 =	$f3
    184  10000 ????		00 f4	    spritesort4 =	$f4
    185  10000 ????		00 f5	    spritesort5 =	$f5
    186  10000 ????
    187  10000 ????		00 f6	    stack1     =	$f6
    188  10000 ????		00 f7	    stack2     =	$f7
    189  10000 ????		00 f8	    stack3     =	$f8
    190  10000 ????		00 f9	    stack4     =	$f9
    191  10000 ????						; the stack bytes above may be used in the kernel
    192  10000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  10000 ????
    194  10000 ????				       MAC	return
    195  10000 ????				       ifnconst	bankswitch
    196  10000 ????				       rts
    197  10000 ????				       else
    198  10000 ????				       jmp	BS_return
    199  10000 ????				       endif
    200  10000 ????				       ENDM		; auto-return from either a regular or bankswitched module
------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"2600basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 e8	    soundb     =	r
      4  10000 ????
      5  10000 ????		00 e9	    sounda     =	s
      6  10000 ????
      7  10000 ????		00 01	    multisprite =	1
------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm
      8  10000 ????			   -	       ifconst	bankswitch
      9  10000 ????			   -	       if	bankswitch == 8
     10  10000 ????			   -	       ORG	$1000
     11  10000 ????			   -	       RORG	$D000
     12  10000 ????			   -	       endif
     13  10000 ????			   -	       if	bankswitch == 16
     14  10000 ????			   -	       ORG	$1000
     15  10000 ????			   -	       RORG	$9000
     16  10000 ????			   -	       endif
     17  10000 ????			   -	       if	bankswitch == 32
     18  10000 ????			   -	       ORG	$1000
     19  10000 ????			   -	       RORG	$1000
     20  10000 ????			   -	       endif
     21  10000 ????			   -	       if	bankswitch == 64
     22  10000 ????			   -	       ORG	$1000
     23  10000 ????			   -	       RORG	$1000
     24  10000 ????			   -	       endif
     25  10000 ????				       else
     26  f000					      ORG	$F000
     27  f000					      endif
     28  f000
     29  f000				  -	      ifconst	bankswitch_hotspot
     30  f000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  f000				  -	      .byte	234	; stop unexpected bankswitches
     32  f000				  -	      endif
     33  f000					      endif
     34  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
     35  f000
     36  f000				   FineAdjustTableBegin
     37  f000		       60		      .byte.b	%01100000	;left 6
     38  f001		       50		      .byte.b	%01010000
     39  f002		       40		      .byte.b	%01000000
     40  f003		       30		      .byte.b	%00110000
     41  f004		       20		      .byte.b	%00100000
     42  f005		       10		      .byte.b	%00010000
     43  f006		       00		      .byte.b	%00000000	;left 0
     44  f007		       f0		      .byte.b	%11110000
     45  f008		       e0		      .byte.b	%11100000
     46  f009		       d0		      .byte.b	%11010000
     47  f00a		       c0		      .byte.b	%11000000
     48  f00b		       b0		      .byte.b	%10110000
     49  f00c		       a0		      .byte.b	%10100000
     50  f00d		       90		      .byte.b	%10010000
     51  f00e		       80		      .byte.b	%10000000	;right 8
     52  f00e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
     53  f00f
     54  f00f				   PFStart
     55  f00f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
     56  f017				   blank_pf
     57  f017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
     58  f01f							; .byte 43,21,0,10,0,0,0,5
     59  f01f				  -	      ifconst	screenheight
     60  f01f				  -pfsub
     61  f01f				  -	      .byte	8,4,2,2,1,0,0,1,0
     62  f01f					      endif
     63  f01f							;--set initial P1 positions
     64  f01f				   multisprite_setup
     65  f01f		       a9 0f		      lda	#15
     66  f021		       85 c4		      sta	pfheight
     67  f023
     68  f023		       a2 04		      ldx	#4
     69  f025							; stx temp3
     70  f025				   SetCopyHeight
     71  f025							;	lda #76
     72  f025							;	sta NewSpriteX,X
     73  f025							;	lda CopyColorData,X
     74  f025							;	sta NewCOLUP1,X
     75  f025							;lda SpriteHeightTable,X
     76  f025							; sta spriteheight,x
     77  f025		       8a		      txa
     78  f026		       95 9d		      sta	SpriteGfxIndex,X
     79  f028		       95 f1		      sta	spritesort,X
     80  f02a		       ca		      dex
     81  f02b		       10 f8		      bpl	SetCopyHeight
     82  f02d
     83  f02d
     84  f02d
     85  f02d							; since we can't turn off pf, point PF to zeros here
     86  f02d		       a9 f0		      lda	#>blank_pf
     87  f02f		       85 be		      sta	PF2pointer+1
     88  f031		       85 bc		      sta	PF1pointer+1
     89  f033		       a9 17		      lda	#<blank_pf
     90  f035		       85 bd		      sta	PF2pointer
     91  f037		       85 bb		      sta	PF1pointer
     92  f039		       60		      rts
     93  f03a
     94  f03a				   drawscreen
     95  f03a				  -	      ifconst	debugscore
     96  f03a				  -	      jsr	debugcycles
     97  f03a					      endif
     98  f03a
     99  f03a				   WaitForOverscanEnd
    100  f03a		       ad 84 02 	      lda	INTIM
    101  f03d		       30 fb		      bmi	WaitForOverscanEnd
    102  f03f
    103  f03f		       a9 02		      lda	#2
    104  f041		       85 02		      sta	WSYNC
    105  f043		       85 00		      sta	VSYNC
    106  f045		       85 02		      sta	WSYNC
    107  f047		       85 02		      sta	WSYNC
    108  f049		       4a		      lsr
    109  f04a		       85 27		      sta	VDELBL
    110  f04c		       85 25		      sta	VDELP0
    111  f04e		       85 02		      sta	WSYNC
    112  f050		       85 00		      sta	VSYNC	;turn off VSYNC
    113  f052				  -	      ifconst	overscan_time
    114  f052				  -	      lda	#overscan_time+5+128
    115  f052					      else
    116  f052		       a9 aa		      lda	#42+128
    117  f054					      endif
    118  f054		       8d 96 02 	      sta	TIM64T
    119  f057
    120  f057							; run possible vblank bB code
    121  f057				  -	      ifconst	vblank_bB_code
    122  f057				  -	      jsr	vblank_bB_code
    123  f057					      endif
    124  f057
    125  f057		       20 dc f1 	      jsr	setscorepointers
    126  f05a		       20 79 f3 	      jsr	SetupP1Subroutine
    127  f05d
    128  f05d							;-------------
    129  f05d
    130  f05d
    131  f05d
    132  f05d
    133  f05d
    134  f05d							;--position P0, M0, M1, BL
    135  f05d
    136  f05d		       20 b5 f0 	      jsr	PrePositionAllObjects
    137  f060
    138  f060							;--set up player 0 pointer
    139  f060
    140  f060		       c6 8d		      dec	player0y
    141  f062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
    142  f064		       38		      sec
    143  f065		       e5 8d		      sbc	player0y
    144  f067		       18		      clc
    145  f068		       65 b0		      adc	player0height
    146  f06a		       85 a2		      sta	player0pointer
    147  f06c
    148  f06c		       a5 8d		      lda	player0y
    149  f06e		       85 cf		      sta	P0Top
    150  f070		       38		      sec
    151  f071		       e5 b0		      sbc	player0height
    152  f073		       18		      clc
    153  f074		       69 80		      adc	#$80
    154  f076		       85 a4		      sta	P0Bottom
    155  f078
    156  f078
    157  f078							;--some final setup
    158  f078
    159  f078		       a2 04		      ldx	#4
    160  f07a		       a9 80		      lda	#$80
    161  f07c				   cycle74_HMCLR
    162  f07c		       95 20		      sta	HMP0,X
    163  f07e		       ca		      dex
    164  f07f		       10 fb		      bpl	cycle74_HMCLR
    165  f081							;	sta HMCLR
    166  f081
    167  f081
    168  f081		       a9 00		      lda	#0
    169  f083		       85 0e		      sta	PF1
    170  f085		       85 0f		      sta	PF2
    171  f087		       85 1b		      sta	GRP0
    172  f089		       85 1c		      sta	GRP1
    173  f08b
    174  f08b
    175  f08b		       20 d0 f0 	      jsr	KernelSetupSubroutine
    176  f08e
    177  f08e				   WaitForVblankEnd
    178  f08e		       ad 84 02 	      lda	INTIM
    179  f091		       30 fb		      bmi	WaitForVblankEnd
    180  f093		       a9 00		      lda	#0
    181  f095		       85 02		      sta	WSYNC
    182  f097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
    183  f099		       85 2c		      sta	CXCLR
    184  f09b
    185  f09b
    186  f09b		       4c 5d f1 	      jmp	KernelRoutine
    187  f09e
    188  f09e
    189  f09e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
    190  f09e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
    191  f09e							;if you do not wish to write to P1 during this function, make
    192  f09e							;sure Y==0 before you call it.  This function will change Y, and A
    193  f09e							;will be the value put into HMxx when returned.
    194  f09e							;Call this function with at least 11 cycles left in the scanline 
    195  f09e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
    196  f09e							;into the second scanline
    197  f09e		       38		      sec
    198  f09f		       85 02		      sta	WSYNC	;begin line 1
    199  f0a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
    200  f0a4				   DivideBy15Loop
    201  f0a4		       e9 0f		      sbc	#15
    202  f0a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
    203  f0a8
    204  f0a8		       a8		      tay		;+2	10/15/...60
    205  f0a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
    206  f0ac
    207  f0ac							;	15
    208  f0ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
    209  f0ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
    210  f0b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
    211  f0b2		       85 2a		      sta	HMOVE	;+3
    212  f0b4		       60		      rts		;+6	 9
    213  f0b5
    214  f0b5							;-------------------------------------------------------------------------
    215  f0b5
    216  f0b5				   PrePositionAllObjects
    217  f0b5
    218  f0b5		       a2 04		      ldx	#4
    219  f0b7		       a5 82		      lda	ballx
    220  f0b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
    221  f0bc
    222  f0bc		       ca		      dex
    223  f0bd		       a5 81		      lda	missile1x
    224  f0bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
    225  f0c2
    226  f0c2		       ca		      dex
    227  f0c3		       a5 80		      lda	missile0x
    228  f0c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
    229  f0c8
    230  f0c8		       ca		      dex
    231  f0c9		       ca		      dex
    232  f0ca		       a5 84		      lda	player0x
    233  f0cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
    234  f0cf
    235  f0cf		       60		      rts
    236  f0d0
    237  f0d0
    238  f0d0							;-------------------------------------------------------------------------
    239  f0d0
    240  f0d0
    241  f0d0
    242  f0d0
    243  f0d0
    244  f0d0
    245  f0d0
    246  f0d0
    247  f0d0							;-------------------------------------------------------------------------
    248  f0d0
    249  f0d0
    250  f0d0				   KernelSetupSubroutine
    251  f0d0
    252  f0d0		       a2 04		      ldx	#4
    253  f0d2				   AdjustYValuesUpLoop
    254  f0d2		       b5 8e		      lda	NewSpriteY,X
    255  f0d4		       18		      clc
    256  f0d5		       69 02		      adc	#2
    257  f0d7		       95 8e		      sta	NewSpriteY,X
    258  f0d9		       ca		      dex
    259  f0da		       10 f6		      bpl	AdjustYValuesUpLoop
    260  f0dc
    261  f0dc
    262  f0dc		       a6 cd		      ldx	temp3	; first sprite displayed
    263  f0de
    264  f0de		       b5 9d		      lda	SpriteGfxIndex,x
    265  f0e0		       a8		      tay
    266  f0e1		       b9 8e 00 	      lda	NewSpriteY,y
    267  f0e4		       85 ce		      sta	RepoLine
    268  f0e6
    269  f0e6		       b5 9c		      lda	SpriteGfxIndex-1,x
    270  f0e8		       a8		      tay
    271  f0e9		       b9 8e 00 	      lda	NewSpriteY,y
    272  f0ec		       85 d0		      sta	temp6
    273  f0ee
    274  f0ee		       86 83		      stx	SpriteIndex
    275  f0f0
    276  f0f0
    277  f0f0
    278  f0f0		       a9 ff		      lda	#255
    279  f0f2		       85 a5		      sta	P1Bottom
    280  f0f4
    281  f0f4		       a5 8d		      lda	player0y
    282  f0f6				  -	      ifconst	screenheight
    283  f0f6				  -	      cmp	#screenheight+1
    284  f0f6					      else
    285  f0f6		       c9 59		      cmp	#$59
    286  f0f8					      endif
    287  f0f8		       90 04		      bcc	nottoohigh
    288  f0fa		       a5 a4		      lda	P0Bottom
    289  f0fc		       85 cf		      sta	P0Top
    290  f0fe
    291  f0fe
    292  f0fe
    293  f0fe				   nottoohigh
    294  f0fe		       60		      rts
    295  f0ff
    296  f0ff							;-------------------------------------------------------------------------
    297  f0ff
    298  f0ff
    299  f0ff
    300  f0ff
    301  f0ff
    302  f0ff							;*************************************************************************
    303  f0ff
    304  f0ff							;-------------------------------------------------------------------------
    305  f0ff							;-------------------------Data Below--------------------------------------
    306  f0ff							;-------------------------------------------------------------------------
    307  f0ff
    308  f0ff				   MaskTable
    309  f0ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
    310  f104
    311  f104							; shove 6-digit score routine here
    312  f104
    313  f104				   sixdigscore
    314  f104		       a9 00		      lda	#0
    315  f106							;	sta COLUBK
    316  f106		       85 0d		      sta	PF0
    317  f108		       85 0e		      sta	PF1
    318  f10a		       85 0f		      sta	PF2
    319  f10c		       85 1f		      sta	ENABL
    320  f10e		       85 1d		      sta	ENAM0
    321  f110		       85 1e		      sta	ENAM1
    322  f112							;end of kernel here
    323  f112
    324  f112
    325  f112							; 6 digit score routine
    326  f112							; lda #0
    327  f112							; sta PF1
    328  f112							; sta PF2
    329  f112							; tax
    330  f112
    331  f112		       85 02		      sta	WSYNC	;,x
    332  f114
    333  f114							;		  STA WSYNC ;first one, need one more
    334  f114		       85 0b		      sta	REFP0
    335  f116		       85 0c		      sta	REFP1
    336  f118		       85 1b		      STA	GRP0
    337  f11a		       85 1c		      STA	GRP1
    338  f11c		       85 2b		      sta	HMCLR
    339  f11e
    340  f11e							; restore P0pointer
    341  f11e
    342  f11e		       a5 a2		      lda	player0pointer
    343  f120		       18		      clc
    344  f121		       65 8d		      adc	player0y
    345  f123		       38		      sec
    346  f124		       e5 b0		      sbc	player0height
    347  f126		       85 a2		      sta	player0pointer
    348  f128		       e6 8d		      inc	player0y
    349  f12a
    350  f12a				  -	      ifconst	vblank_time
    351  f12a				  -	      ifconst	screenheight
    352  f12a				  -	      if	screenheight == 84
    353  f12a				  -	      lda	#vblank_time+9+128+10
    354  f12a				  -	      else
    355  f12a				  -	      lda	#vblank_time+9+128+19
    356  f12a				  -	      endif
    357  f12a				  -	      else
    358  f12a				  -	      lda	#vblank_time+9+128
    359  f12a				  -	      endif
    360  f12a					      else
    361  f12a				  -	      ifconst	screenheight
    362  f12a				  -	      if	screenheight == 84
    363  f12a				  -	      lda	#52+128+10
    364  f12a				  -	      else
    365  f12a				  -	      lda	#52+128+19
    366  f12a				  -	      endif
    367  f12a					      else
    368  f12a		       a9 b4		      lda	#52+128
    369  f12c					      endif
    370  f12c					      endif
    371  f12c
    372  f12c		       8d 96 02 	      sta	TIM64T
    373  f12f				  -	      ifconst	minikernel
    374  f12f				  -	      jsr	minikernel
    375  f12f					      endif
    376  f12f				  -	      ifconst	noscore
    377  f12f				  -	      pla
    378  f12f				  -	      pla
    379  f12f				  -	      jmp	skipscore
    380  f12f					      endif
    381  f12f
    382  f12f							; score pointers contain:
    383  f12f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
    384  f12f							; swap lo2->temp1
    385  f12f							; swap lo4->temp3
    386  f12f							; swap lo6->temp5
    387  f12f
    388  f12f		       a5 ca		      lda	scorepointers+5
    389  f131		       85 cf		      sta	temp5
    390  f133		       a5 c6		      lda	scorepointers+1
    391  f135		       85 cb		      sta	temp1
    392  f137		       a5 c8		      lda	scorepointers+3
    393  f139		       85 cd		      sta	temp3
    394  f13b
    395  f13b		       a9 ff		      lda	#>scoretable
    396  f13d		       85 c6		      sta	scorepointers+1
    397  f13f		       85 c8		      sta	scorepointers+3
    398  f141		       85 ca		      sta	scorepointers+5
    399  f143		       85 cc		      sta	temp2
    400  f145		       85 ce		      sta	temp4
    401  f147		       85 d0		      sta	temp6
    402  f149
    403  f149		       60		      rts
    404  f14a
    405  f14a
    406  f14a
    407  f14a							;-------------------------------------------------------------------------
    408  f14a							;----------------------Kernel Routine-------------------------------------
    409  f14a							;-------------------------------------------------------------------------
    410  f14a
    411  f14a
    412  f14a							;-------------------------------------------------------------------------
    413  f14a							; repeat $f147-*
    414  f14a							; brk
    415  f14a							; repend
    416  f14a							;	org $F240
    417  f14a
    418  f14a				   SwitchDrawP0K1		;	72
    419  f14a		       a5 a4		      lda	P0Bottom
    420  f14c		       85 cf		      sta	P0Top	;+6	 2
    421  f14e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
    422  f151
    423  f151				   WaitDrawP0K1 		;	74
      0  f151					      SLEEP	4	;+4	 2
      1  f151				   .CYCLES    SET	4
      2  f151
      3  f151				  -	      IF	.CYCLES < 2
      4  f151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f151				  -	      ERR
      6  f151					      ENDIF
      7  f151
      8  f151				  -	      IF	.CYCLES & 1
      9  f151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f151				  -	      nop	0
     11  f151				  -	      ELSE
     12  f151				  -	      bit	VSYNC
     13  f151				  -	      ENDIF
     14  f151				  -.CYCLES    SET	.CYCLES - 3
     15  f151					      ENDIF
     16  f151
     17  f151					      REPEAT	.CYCLES / 2
     18  f151		       ea		      nop
     17  f151					      REPEND
     18  f152		       ea		      nop
     19  f153					      REPEND
    425  f153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
    426  f156
    427  f156				   SkipDrawP1K1 		;	11
    428  f156		       a9 00		      lda	#0
    429  f158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
    430  f15a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
    431  f15d
    432  f15d							;-------------------------------------------------------------------------
    433  f15d
    434  f15d				   KernelRoutine
    435  f15d					      ifnconst	screenheight
      0  f15d					      sleep	12
      1  f15d				   .CYCLES    SET	12
      2  f15d
      3  f15d				  -	      IF	.CYCLES < 2
      4  f15d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f15d				  -	      ERR
      6  f15d					      ENDIF
      7  f15d
      8  f15d				  -	      IF	.CYCLES & 1
      9  f15d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f15d				  -	      nop	0
     11  f15d				  -	      ELSE
     12  f15d				  -	      bit	VSYNC
     13  f15d				  -	      ENDIF
     14  f15d				  -.CYCLES    SET	.CYCLES - 3
     15  f15d					      ENDIF
     16  f15d
     17  f15d					      REPEAT	.CYCLES / 2
     18  f15d		       ea		      nop
     17  f15d					      REPEND
     18  f15e		       ea		      nop
     17  f15e					      REPEND
     18  f15f		       ea		      nop
     17  f15f					      REPEND
     18  f160		       ea		      nop
     17  f160					      REPEND
     18  f161		       ea		      nop
     17  f161					      REPEND
     18  f162		       ea		      nop
     19  f163					      REPEND
    437  f163							; jsr wastetime ; waste 12 cycles
    438  f163				  -	      else
    439  f163				  -	      sleep	6
    440  f163					      endif
    441  f163		       ba		      tsx
    442  f164		       86 f6		      stx	stack1
    443  f166		       a2 1f		      ldx	#ENABL
    444  f168		       9a		      txs		;+9	 9
    445  f169
    446  f169		       a2 00		      ldx	#0
    447  f16b		       a5 c4		      lda	pfheight
    448  f16d		       10 01		      bpl	asdhj
    449  f16f		       24		      .byte.b	$24
    450  f170				   asdhj
    451  f170		       aa		      tax
    452  f171
    453  f171							; ldx pfheight
    454  f171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
    455  f174
    456  f174				  -	      ifconst	screenheight
    457  f174				  -	      sec
    458  f174				  -	      if	screenheight == 84
    459  f174				  -	      sbc	pfsub+1,x
    460  f174				  -	      else
    461  f174				  -	      sbc	pfsub,x
    462  f174				  -	      endif
    463  f174					      endif
    464  f174
    465  f174		       85 ba		      sta	pfpixelheight
    466  f176
    467  f176				  -	      ifconst	screenheight
    468  f176				  -	      ldy	#screenheight
    469  f176					      else
    470  f176		       a0 58		      ldy	#88
    471  f178					      endif
    472  f178
    473  f178							;	lda #$02
    474  f178							;	sta COLUBK		;+5	18
    475  f178
    476  f178							; sleep 25
      0  f178					      sleep	2
      1  f178				   .CYCLES    SET	2
      2  f178
      3  f178				  -	      IF	.CYCLES < 2
      4  f178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f178				  -	      ERR
      6  f178					      ENDIF
      7  f178
      8  f178				  -	      IF	.CYCLES & 1
      9  f178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f178				  -	      nop	0
     11  f178				  -	      ELSE
     12  f178				  -	      bit	VSYNC
     13  f178				  -	      ENDIF
     14  f178				  -.CYCLES    SET	.CYCLES - 3
     15  f178					      ENDIF
     16  f178
     17  f178					      REPEAT	.CYCLES / 2
     18  f178		       ea		      nop
     19  f179					      REPEND
    478  f179				   KernelLoopa		;	50
      0  f179					      SLEEP	7	;+4	54
      1  f179				   .CYCLES    SET	7
      2  f179
      3  f179				  -	      IF	.CYCLES < 2
      4  f179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f179				  -	      ERR
      6  f179					      ENDIF
      7  f179
      8  f179					      IF	.CYCLES & 1
      9  f179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f179		       04 00		      nop	0
     11  f17b				  -	      ELSE
     12  f17b				  -	      bit	VSYNC
     13  f17b					      ENDIF
     14  f17b				   .CYCLES    SET	.CYCLES - 3
     15  f17b					      ENDIF
     16  f17b
     17  f17b					      REPEAT	.CYCLES / 2
     18  f17b		       ea		      nop
     17  f17b					      REPEND
     18  f17c		       ea		      nop
     19  f17d					      REPEND
    480  f17d				   KernelLoopb		;	54
      0  f17d					      SLEEP	2	;+12	66
      1  f17d				   .CYCLES    SET	2
      2  f17d
      3  f17d				  -	      IF	.CYCLES < 2
      4  f17d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f17d				  -	      ERR
      6  f17d					      ENDIF
      7  f17d
      8  f17d				  -	      IF	.CYCLES & 1
      9  f17d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f17d				  -	      nop	0
     11  f17d				  -	      ELSE
     12  f17d				  -	      bit	VSYNC
     13  f17d				  -	      ENDIF
     14  f17d				  -.CYCLES    SET	.CYCLES - 3
     15  f17d					      ENDIF
     16  f17d
     17  f17d					      REPEAT	.CYCLES / 2
     18  f17d		       ea		      nop
     19  f17e					      REPEND
    482  f17e		       c4 cf		      cpy	P0Top	;+3	69
    483  f180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
    484  f182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
    485  f184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
    486  f186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
    487  f188				   BackFromSwitchDrawP0K1
    488  f188
    489  f188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
    490  f18a							;		to a value greater than maximum Y value initially
    491  f18a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
    492  f18c		       b1 cc		      lda	(P1display),Y	;+5	15
    493  f18e		       8d 1c 00 	      sta.w	GRP1	;+4	19
    494  f191				   BackFromSkipDrawP1
    495  f191
    496  f191							;fuck	
    497  f191		       84 cb		      sty	temp1
    498  f193		       a4 ba		      ldy	pfpixelheight
    499  f195		       b3 bb		      lax	(PF1pointer),y
    500  f197		       86 0e		      stx	PF1	;+7	26
    501  f199		       b1 bd		      lda	(PF2pointer),y
    502  f19b		       85 0f		      sta	PF2	;+7	33
    503  f19d							;sleep 6
    504  f19d		       86 b7		      stx	PF1temp2
    505  f19f		       85 b9		      sta	PF2temp2
    506  f1a1		       88		      dey
    507  f1a2		       30 35		      bmi	pagewraphandler
    508  f1a4		       b1 bb		      lda	(PF1pointer),y
    509  f1a6				   cyclebalance
    510  f1a6		       85 b6		      sta	PF1temp1
    511  f1a8		       b1 bd		      lda	(PF2pointer),y
    512  f1aa		       85 b8		      sta	PF2temp1
    513  f1ac		       a4 cb		      ldy	temp1
    514  f1ae
    515  f1ae		       a2 1f		      ldx	#ENABL
    516  f1b0		       9a		      txs
    517  f1b1		       c4 8c		      cpy	bally
    518  f1b3		       08		      php		;+6	39	VDEL ball
    519  f1b4
    520  f1b4
    521  f1b4		       c4 8b		      cpy	missile1y
    522  f1b6		       08		      php		;+6	71
    523  f1b7
    524  f1b7		       c4 8a		      cpy	missile0y
    525  f1b9		       08		      php		;+6	 1
    526  f1ba
    527  f1ba
    528  f1ba		       88		      dey		;+2	15
    529  f1bb
    530  f1bb		       c4 ce		      cpy	RepoLine	;+3	18
    531  f1bd		       f0 62		      beq	RepoKernel	;+2	20
    532  f1bf							;	SLEEP 20		;+23	43
      0  f1bf					      sleep	6
      1  f1bf				   .CYCLES    SET	6
      2  f1bf
      3  f1bf				  -	      IF	.CYCLES < 2
      4  f1bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f1bf				  -	      ERR
      6  f1bf					      ENDIF
      7  f1bf
      8  f1bf				  -	      IF	.CYCLES & 1
      9  f1bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f1bf				  -	      nop	0
     11  f1bf				  -	      ELSE
     12  f1bf				  -	      bit	VSYNC
     13  f1bf				  -	      ENDIF
     14  f1bf				  -.CYCLES    SET	.CYCLES - 3
     15  f1bf					      ENDIF
     16  f1bf
     17  f1bf					      REPEAT	.CYCLES / 2
     18  f1bf		       ea		      nop
     17  f1bf					      REPEND
     18  f1c0		       ea		      nop
     17  f1c0					      REPEND
     18  f1c1		       ea		      nop
     19  f1c2					      REPEND
    534  f1c2
    535  f1c2				   newrepo		; since we have time here, store next repoline
    536  f1c2		       a6 83		      ldx	SpriteIndex
    537  f1c4		       b5 9c		      lda	SpriteGfxIndex-1,x
    538  f1c6		       aa		      tax
    539  f1c7		       b5 8e		      lda	NewSpriteY,x
    540  f1c9		       85 d0		      sta	temp6
      0  f1cb					      sleep	4
      1  f1cb				   .CYCLES    SET	4
      2  f1cb
      3  f1cb				  -	      IF	.CYCLES < 2
      4  f1cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f1cb				  -	      ERR
      6  f1cb					      ENDIF
      7  f1cb
      8  f1cb				  -	      IF	.CYCLES & 1
      9  f1cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f1cb				  -	      nop	0
     11  f1cb				  -	      ELSE
     12  f1cb				  -	      bit	VSYNC
     13  f1cb				  -	      ENDIF
     14  f1cb				  -.CYCLES    SET	.CYCLES - 3
     15  f1cb					      ENDIF
     16  f1cb
     17  f1cb					      REPEAT	.CYCLES / 2
     18  f1cb		       ea		      nop
     17  f1cb					      REPEND
     18  f1cc		       ea		      nop
     19  f1cd					      REPEND
    542  f1cd
    543  f1cd				   BackFromRepoKernel
    544  f1cd		       98		      tya		;+2	45
    545  f1ce		       25 c4		      and	pfheight	;+2	47
    546  f1d0		       d0 a7		      bne	KernelLoopa	;+2	49
    547  f1d2		       c6 ba		      dec	pfpixelheight
    548  f1d4		       10 a7		      bpl	KernelLoopb	;+3	54
    549  f1d6							;	bmi donewkernel		;+3	54
    550  f1d6							;	bne KernelLoopb+1		;+3	54
    551  f1d6
    552  f1d6				   donewkernel
    553  f1d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
    554  f1d9
    555  f1d9				   pagewraphandler
    556  f1d9		       4c a6 f1 	      jmp	cyclebalance
    557  f1dc
    558  f1dc							;-------------------------------------------------------------------------
    559  f1dc
    560  f1dc							; room here for score?
    561  f1dc
    562  f1dc				   setscorepointers
    563  f1dc		       a7 d4		      lax	score+2
    564  f1de		       20 f8 f1 	      jsr	scorepointerset
    565  f1e1		       84 ca		      sty	scorepointers+5
    566  f1e3		       86 c7		      stx	scorepointers+2
    567  f1e5		       a7 d3		      lax	score+1
    568  f1e7		       20 f8 f1 	      jsr	scorepointerset
    569  f1ea		       84 c9		      sty	scorepointers+4
    570  f1ec		       86 c6		      stx	scorepointers+1
    571  f1ee		       a7 d2		      lax	score
    572  f1f0		       20 f8 f1 	      jsr	scorepointerset
    573  f1f3		       84 c8		      sty	scorepointers+3
    574  f1f5		       86 c5		      stx	scorepointers
    575  f1f7				   wastetime
    576  f1f7		       60		      rts
    577  f1f8
    578  f1f8				   scorepointerset
    579  f1f8		       29 0f		      and	#$0F
    580  f1fa		       0a		      asl
    581  f1fb		       0a		      asl
    582  f1fc		       0a		      asl
    583  f1fd		       69 9c		      adc	#<scoretable
    584  f1ff		       a8		      tay
    585  f200		       8a		      txa
    586  f201		       29 f0		      and	#$F0
    587  f203		       4a		      lsr
    588  f204		       69 9c		      adc	#<scoretable
    589  f206		       aa		      tax
    590  f207		       60		      rts
    591  f208							;	align 256
    592  f208
    593  f208				   SwitchDrawP0KR		;	45
    594  f208		       a5 a4		      lda	P0Bottom
    595  f20a		       85 cf		      sta	P0Top	;+6	51
    596  f20c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
    597  f20f
    598  f20f				   WaitDrawP0KR 		;	47
      0  f20f					      SLEEP	4	;+4	51
      1  f20f				   .CYCLES    SET	4
      2  f20f
      3  f20f				  -	      IF	.CYCLES < 2
      4  f20f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f20f				  -	      ERR
      6  f20f					      ENDIF
      7  f20f
      8  f20f				  -	      IF	.CYCLES & 1
      9  f20f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f20f				  -	      nop	0
     11  f20f				  -	      ELSE
     12  f20f				  -	      bit	VSYNC
     13  f20f				  -	      ENDIF
     14  f20f				  -.CYCLES    SET	.CYCLES - 3
     15  f20f					      ENDIF
     16  f20f
     17  f20f					      REPEAT	.CYCLES / 2
     18  f20f		       ea		      nop
     17  f20f					      REPEND
     18  f210		       ea		      nop
     19  f211					      REPEND
    600  f211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
    601  f214
    602  f214							;-----------------------------------------------------------
    603  f214
    604  f214				   noUpdateXKR
    605  f214		       a2 01		      ldx	#1
    606  f216		       cc cf 00 	      cpy.w	P0Top
    607  f219		       4c 2b f2 	      JMP	retXKR
    608  f21c
    609  f21c				   skipthis
    610  f21c		       a2 01		      ldx	#1
    611  f21e		       4c 6d f2 	      jmp	goback
    612  f221
    613  f221				   RepoKernel		;	22	crosses page boundary
    614  f221		       98		      tya
    615  f222		       25 c4		      and	pfheight	;+2	26
    616  f224		       d0 ee		      bne	noUpdateXKR	;+2	28
    617  f226		       aa		      tax
    618  f227							;	dex			;+2	30
    619  f227		       c6 ba		      dec	pfpixelheight
    620  f229							;	stx Temp		;+3	35
    621  f229							;	SLEEP 3
    622  f229
    623  f229		       c4 cf		      cpy	P0Top	;+3	42
    624  f22b				   retXKR
    625  f22b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
    626  f22d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
    627  f22f		       b1 a2		      lda	(player0pointer),Y	;+5	51
    628  f231		       85 1b		      sta	GRP0	;+3	54	VDEL
    629  f233				   BackFromSwitchDrawP0KR
    630  f233		       38		      sec		;+2	56
    631  f234
    632  f234
    633  f234
    634  f234		       b5 b8		      lda	PF2temp1,X
    635  f236		       b4 b6		      ldy	PF1temp1,X
    636  f238
    637  f238		       a6 83		      ldx	SpriteIndex	;+3	 2
    638  f23a
    639  f23a		       85 0f		      sta	PF2	;+7	63
    640  f23c
    641  f23c		       b5 9d		      lda	SpriteGfxIndex,x
    642  f23e		       84 0e		      sty	PF1	;+7	70	too early?
    643  f240		       aa		      tax
    644  f241		       a9 00		      lda	#0
    645  f243		       85 1c		      sta	GRP1	;+5	75	to display player 0
    646  f245		       b5 85		      lda	NewSpriteX,X	;+4	 6
    647  f247
    648  f247				   DivideBy15LoopK		;	 6	(carry set above)
    649  f247		       e9 0f		      sbc	#15
    650  f249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
    651  f24b
    652  f24b		       aa		      tax		;+2	12/17/...62
    653  f24c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
    654  f24f
    655  f24f		       85 21		      sta	HMP1	;+3	20/25/...70
    656  f251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
    657  f253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
    658  f255							;sta HMOVE			;+3	 3
    659  f255
    660  f255		       a2 1f		      ldx	#ENABL
    661  f257		       9a		      txs		;+4	25
    662  f258		       a4 ce		      ldy	RepoLine	; restore y
    663  f25a		       c4 8c		      cpy	bally
    664  f25c		       08		      php		;+6	 9	VDEL ball
    665  f25d
    666  f25d		       c4 8b		      cpy	missile1y
    667  f25f		       08		      php		;+6	15
    668  f260
    669  f260		       c4 8a		      cpy	missile0y
    670  f262		       08		      php		;+6	21
    671  f263
    672  f263
    673  f263
    674  f263
    675  f263
    676  f263							;15 cycles
    677  f263		       98		      tya
    678  f264		       25 c4		      and	pfheight
    679  f266							;eor #1
    680  f266		       29 fe		      and	#$FE
    681  f268		       d0 b2		      bne	skipthis
    682  f26a		       aa		      tax
      0  f26b					      sleep	4
      1  f26b				   .CYCLES    SET	4
      2  f26b
      3  f26b				  -	      IF	.CYCLES < 2
      4  f26b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f26b				  -	      ERR
      6  f26b					      ENDIF
      7  f26b
      8  f26b				  -	      IF	.CYCLES & 1
      9  f26b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f26b				  -	      nop	0
     11  f26b				  -	      ELSE
     12  f26b				  -	      bit	VSYNC
     13  f26b				  -	      ENDIF
     14  f26b				  -.CYCLES    SET	.CYCLES - 3
     15  f26b					      ENDIF
     16  f26b
     17  f26b					      REPEAT	.CYCLES / 2
     18  f26b		       ea		      nop
     17  f26b					      REPEND
     18  f26c		       ea		      nop
     19  f26d					      REPEND
    684  f26d							;	sleep 2
    685  f26d				   goback
    686  f26d
    687  f26d		       88		      dey
    688  f26e		       c4 cf		      cpy	P0Top	;+3	52
    689  f270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
    690  f272		       10 67		      bpl	WaitDrawP0KV	;+2	56
    691  f274		       b1 a2		      lda	(player0pointer),Y	;+5	61
    692  f276		       85 1b		      sta	GRP0	;+3	64	VDEL
    693  f278				   BackFromSwitchDrawP0KV
    694  f278
    695  f278							; sleep 3
    696  f278
    697  f278		       b5 b8		      lda	PF2temp1,X
    698  f27a		       85 0f		      sta	PF2	;+7	 5
    699  f27c		       b5 b6		      lda	PF1temp1,X
    700  f27e		       85 0e		      sta	PF1	;+7	74 
    701  f280		       85 2a		      sta	HMOVE
    702  f282
    703  f282		       a9 00		      lda	#0
    704  f284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
    705  f286
    706  f286		       a2 1f		      ldx	#ENABL
    707  f288		       9a		      txs		;+4	 8
    708  f289
    709  f289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
    710  f28b							;--now, set all new variables and return to main kernel loop
    711  f28b
    712  f28b
    713  f28b							;
    714  f28b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
    715  f28d		       aa		      tax		;+2	33
    716  f28e							;
    717  f28e
    718  f28e
    719  f28e
    720  f28e		       b5 93		      lda	NewNUSIZ,X
    721  f290		       85 05		      sta	NUSIZ1	;+7	20
    722  f292		       85 0c		      sta	REFP1
    723  f294		       b5 98		      lda	NewCOLUP1,X
    724  f296		       85 07		      sta	COLUP1	;+7	27
    725  f298
    726  f298							;	lda SpriteGfxIndex,X	;+4	31
    727  f298							;	tax				;+2	33
    728  f298							;fuck2
    729  f298		       b5 8e		      lda	NewSpriteY,X	;+4	46
    730  f29a		       38		      sec		;+2	38
    731  f29b		       f5 b1		      sbc	spriteheight,X	;+4	42
    732  f29d		       85 a5		      sta	P1Bottom	;+3	45
    733  f29f
      0  f29f					      sleep	6
      1  f29f				   .CYCLES    SET	6
      2  f29f
      3  f29f				  -	      IF	.CYCLES < 2
      4  f29f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f29f				  -	      ERR
      6  f29f					      ENDIF
      7  f29f
      8  f29f				  -	      IF	.CYCLES & 1
      9  f29f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f29f				  -	      nop	0
     11  f29f				  -	      ELSE
     12  f29f				  -	      bit	VSYNC
     13  f29f				  -	      ENDIF
     14  f29f				  -.CYCLES    SET	.CYCLES - 3
     15  f29f					      ENDIF
     16  f29f
     17  f29f					      REPEAT	.CYCLES / 2
     18  f29f		       ea		      nop
     17  f29f					      REPEND
     18  f2a0		       ea		      nop
     17  f2a0					      REPEND
     18  f2a1		       ea		      nop
     19  f2a2					      REPEND
    735  f2a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
    736  f2a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
    737  f2a6		       85 cc		      sta	P1display	;+3	55
    738  f2a8		       b5 ab		      lda	player1pointerhi,X
    739  f2aa		       85 cd		      sta	P1display+1	;+7	62
    740  f2ac
    741  f2ac
    742  f2ac		       c4 8c		      cpy	bally
    743  f2ae		       08		      php		;+6	68	VDELed
    744  f2af
    745  f2af		       c4 8b		      cpy	missile1y
    746  f2b1		       08		      php		;+6	74
    747  f2b2
    748  f2b2		       c4 8a		      cpy	missile0y
    749  f2b4		       08		      php		;+6	 4
    750  f2b5
    751  f2b5
    752  f2b5
    753  f2b5							; lda SpriteGfxIndex-1,x
    754  f2b5							; sleep 3
    755  f2b5		       c6 83		      dec	SpriteIndex	;+5	13
    756  f2b7							; tax
    757  f2b7							; lda NewSpriteY,x
    758  f2b7							; sta RepoLine
    759  f2b7
    760  f2b7							; 10 cycles below...
    761  f2b7		       10 05		      bpl	SetNextLine
    762  f2b9		       a9 ff		      lda	#255
    763  f2bb		       4c c1 f2 	      jmp	SetLastLine
    764  f2be				   SetNextLine
    765  f2be							;	lda NewSpriteY-1,x
    766  f2be		       ad d0 00 	      lda.w	temp6
    767  f2c1				   SetLastLine
    768  f2c1		       85 ce		      sta	RepoLine
    769  f2c3
    770  f2c3		       98		      tya
    771  f2c4		       25 c4		      and	pfheight
    772  f2c6		       d0 06		      bne	nodec
    773  f2c8		       c6 ba		      dec	pfpixelheight
    774  f2ca		       88		      dey		;+2	30
    775  f2cb
    776  f2cb							; 10 cycles 
    777  f2cb
    778  f2cb
    779  f2cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
    780  f2ce
    781  f2ce				   nodec
      0  f2ce					      sleep	4
      1  f2ce				   .CYCLES    SET	4
      2  f2ce
      3  f2ce				  -	      IF	.CYCLES < 2
      4  f2ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f2ce				  -	      ERR
      6  f2ce					      ENDIF
      7  f2ce
      8  f2ce				  -	      IF	.CYCLES & 1
      9  f2ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f2ce				  -	      nop	0
     11  f2ce				  -	      ELSE
     12  f2ce				  -	      bit	VSYNC
     13  f2ce				  -	      ENDIF
     14  f2ce				  -.CYCLES    SET	.CYCLES - 3
     15  f2ce					      ENDIF
     16  f2ce
     17  f2ce					      REPEAT	.CYCLES / 2
     18  f2ce		       ea		      nop
     17  f2ce					      REPEND
     18  f2cf		       ea		      nop
     19  f2d0					      REPEND
    783  f2d0		       88		      dey
    784  f2d1		       4c cd f1 	      jmp	BackFromRepoKernel
    785  f2d4
    786  f2d4							;-------------------------------------------------------------------------
    787  f2d4
    788  f2d4
    789  f2d4				   SwitchDrawP0KV		;	69
    790  f2d4		       a5 a4		      lda	P0Bottom
    791  f2d6		       85 cf		      sta	P0Top	;+6	75
    792  f2d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
    793  f2db
    794  f2db				   WaitDrawP0KV 		;	71
      0  f2db					      SLEEP	4	;+4	75
      1  f2db				   .CYCLES    SET	4
      2  f2db
      3  f2db				  -	      IF	.CYCLES < 2
      4  f2db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f2db				  -	      ERR
      6  f2db					      ENDIF
      7  f2db
      8  f2db				  -	      IF	.CYCLES & 1
      9  f2db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f2db				  -	      nop	0
     11  f2db				  -	      ELSE
     12  f2db				  -	      bit	VSYNC
     13  f2db				  -	      ENDIF
     14  f2db				  -.CYCLES    SET	.CYCLES - 3
     15  f2db					      ENDIF
     16  f2db
     17  f2db					      REPEAT	.CYCLES / 2
     18  f2db		       ea		      nop
     17  f2db					      REPEND
     18  f2dc		       ea		      nop
     19  f2dd					      REPEND
    796  f2dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
    797  f2e0
    798  f2e0							;-------------------------------------------------------------------------
    799  f2e0
    800  f2e0				   DoneWithKernel
    801  f2e0
    802  f2e0				   BottomOfKernelLoop
    803  f2e0
    804  f2e0		       85 02		      sta	WSYNC
    805  f2e2		       a6 f6		      ldx	stack1
    806  f2e4		       9a		      txs
    807  f2e5		       20 04 f1 	      jsr	sixdigscore	; set up score
    808  f2e8
    809  f2e8
    810  f2e8		       85 02		      sta	WSYNC
    811  f2ea		       a2 00		      ldx	#0
    812  f2ec		       85 2b		      sta	HMCLR
    813  f2ee		       86 1b		      STx	GRP0
    814  f2f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
    815  f2f2
    816  f2f2		       a0 07		      LDY	#7
    817  f2f4		       84 25		      STy	VDELP0
    818  f2f6		       84 26		      STy	VDELP1
    819  f2f8		       a9 10		      LDA	#$10
    820  f2fa		       85 21		      STA	HMP1
    821  f2fc		       a5 d5		      LDA	scorecolor
    822  f2fe		       85 06		      STA	COLUP0
    823  f300		       85 07		      STA	COLUP1
    824  f302
    825  f302		       a9 03		      LDA	#$03
    826  f304		       85 04		      STA	NUSIZ0
    827  f306		       85 05		      STA	NUSIZ1
    828  f308
    829  f308		       85 10		      STA	RESP0
    830  f30a		       85 11		      STA	RESP1
    831  f30c
      0  f30c					      sleep	9
      1  f30c				   .CYCLES    SET	9
      2  f30c
      3  f30c				  -	      IF	.CYCLES < 2
      4  f30c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f30c				  -	      ERR
      6  f30c					      ENDIF
      7  f30c
      8  f30c					      IF	.CYCLES & 1
      9  f30c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f30c		       04 00		      nop	0
     11  f30e				  -	      ELSE
     12  f30e				  -	      bit	VSYNC
     13  f30e					      ENDIF
     14  f30e				   .CYCLES    SET	.CYCLES - 3
     15  f30e					      ENDIF
     16  f30e
     17  f30e					      REPEAT	.CYCLES / 2
     18  f30e		       ea		      nop
     17  f30e					      REPEND
     18  f30f		       ea		      nop
     17  f30f					      REPEND
     18  f310		       ea		      nop
     19  f311					      REPEND
    833  f311		       b1 c5		      lda	(scorepointers),y
    834  f313		       85 1b		      sta	GRP0
    835  f315				  -	      ifconst	pfscore
    836  f315				  -	      lda	pfscorecolor
    837  f315				  -	      sta	COLUPF
    838  f315					      else
      0  f315					      sleep	6
      1  f315				   .CYCLES    SET	6
      2  f315
      3  f315				  -	      IF	.CYCLES < 2
      4  f315				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f315				  -	      ERR
      6  f315					      ENDIF
      7  f315
      8  f315				  -	      IF	.CYCLES & 1
      9  f315				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f315				  -	      nop	0
     11  f315				  -	      ELSE
     12  f315				  -	      bit	VSYNC
     13  f315				  -	      ENDIF
     14  f315				  -.CYCLES    SET	.CYCLES - 3
     15  f315					      ENDIF
     16  f315
     17  f315					      REPEAT	.CYCLES / 2
     18  f315		       ea		      nop
     17  f315					      REPEND
     18  f316		       ea		      nop
     17  f316					      REPEND
     18  f317		       ea		      nop
     19  f318					      REPEND
    840  f318					      endif
    841  f318
    842  f318		       85 2a		      STA	HMOVE
    843  f31a		       b1 cd		      lda	(scorepointers+8),y
    844  f31c							; sta WSYNC
    845  f31c							;sleep 2
    846  f31c		       4c 29 f3 	      jmp	beginscore
    847  f31f
    848  f31f
    849  f31f				   loop2
    850  f31f		       b1 c5		      lda	(scorepointers),y	;+5  68  204
    851  f321		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
    852  f323				  -	      ifconst	pfscore
    853  f323				  -	      lda.w	pfscore1
    854  f323				  -	      sta	PF1
    855  f323					      else
      0  f323					      sleep	7
      1  f323				   .CYCLES    SET	7
      2  f323
      3  f323				  -	      IF	.CYCLES < 2
      4  f323				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f323				  -	      ERR
      6  f323					      ENDIF
      7  f323
      8  f323					      IF	.CYCLES & 1
      9  f323					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f323		       04 00		      nop	0
     11  f325				  -	      ELSE
     12  f325				  -	      bit	VSYNC
     13  f325					      ENDIF
     14  f325				   .CYCLES    SET	.CYCLES - 3
     15  f325					      ENDIF
     16  f325
     17  f325					      REPEAT	.CYCLES / 2
     18  f325		       ea		      nop
     17  f325					      REPEND
     18  f326		       ea		      nop
     19  f327					      REPEND
    857  f327					      endif
    858  f327							; cycle 0
    859  f327		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
    860  f329				   beginscore
    861  f329		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
    862  f32b		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
    863  f32d		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
    864  f32f		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
    865  f331		       9a		      txs
    866  f332		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  f334					      sleep	3
      1  f334				   .CYCLES    SET	3
      2  f334
      3  f334				  -	      IF	.CYCLES < 2
      4  f334				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f334				  -	      ERR
      6  f334					      ENDIF
      7  f334
      8  f334					      IF	.CYCLES & 1
      9  f334					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f334		       04 00		      nop	0
     11  f336				  -	      ELSE
     12  f336				  -	      bit	VSYNC
     13  f336					      ENDIF
     14  f336				   .CYCLES    SET	.CYCLES - 3
     15  f336					      ENDIF
     16  f336
     17  f336				  -	      REPEAT	.CYCLES / 2
     18  f336				  -	      nop
     19  f336					      REPEND
    868  f336				  -	      ifconst	pfscore
    869  f336				  -	      lda	pfscore2
    870  f336				  -	      sta	PF1
    871  f336					      else
      0  f336					      sleep	6
      1  f336				   .CYCLES    SET	6
      2  f336
      3  f336				  -	      IF	.CYCLES < 2
      4  f336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f336				  -	      ERR
      6  f336					      ENDIF
      7  f336
      8  f336				  -	      IF	.CYCLES & 1
      9  f336				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f336				  -	      nop	0
     11  f336				  -	      ELSE
     12  f336				  -	      bit	VSYNC
     13  f336				  -	      ENDIF
     14  f336				  -.CYCLES    SET	.CYCLES - 3
     15  f336					      ENDIF
     16  f336
     17  f336					      REPEAT	.CYCLES / 2
     18  f336		       ea		      nop
     17  f336					      REPEND
     18  f337		       ea		      nop
     17  f337					      REPEND
     18  f338		       ea		      nop
     19  f339					      REPEND
    873  f339					      endif
    874  f339		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
    875  f33b		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
    876  f33d		       ba		      tsx
    877  f33e		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
    878  f340		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
    879  f342		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
    880  f344		       88		      dey
    881  f345		       10 d8		      bpl	loop2	;+2  60  180
    882  f347		       a6 f6		      ldx	stack1
    883  f349		       9a		      txs
    884  f34a
    885  f34a
    886  f34a							; lda scorepointers+1
    887  f34a		       a4 cb		      ldy	temp1
    888  f34c							; sta temp1
    889  f34c		       84 c6		      sty	scorepointers+1
    890  f34e
    891  f34e		       a9 00		      LDA	#0
    892  f350		       85 1b		      STA	GRP0
    893  f352		       85 1c		      STA	GRP1
    894  f354		       85 0e		      sta	PF1
    895  f356		       85 25		      STA	VDELP0
    896  f358		       85 26		      STA	VDELP1	;do we need these
    897  f35a		       85 04		      STA	NUSIZ0
    898  f35c		       85 05		      STA	NUSIZ1
    899  f35e
    900  f35e							; lda scorepointers+3
    901  f35e		       a4 cd		      ldy	temp3
    902  f360							; sta temp3
    903  f360		       84 c8		      sty	scorepointers+3
    904  f362
    905  f362							; lda scorepointers+5
    906  f362		       a4 cf		      ldy	temp5
    907  f364							; sta temp5
    908  f364		       84 ca		      sty	scorepointers+5
    909  f366
    910  f366
    911  f366							;-------------------------------------------------------------------------
    912  f366							;------------------------Overscan Routine---------------------------------
    913  f366							;-------------------------------------------------------------------------
    914  f366
    915  f366				   OverscanRoutine
    916  f366
    917  f366
    918  f366
    919  f366				   skipscore
    920  f366		       a9 02		      lda	#2
    921  f368		       85 02		      sta	WSYNC
    922  f36a		       85 01		      sta	VBLANK	;turn on VBLANK
    923  f36c
    924  f36c
    925  f36c
    926  f36c
    927  f36c
    928  f36c							;-------------------------------------------------------------------------
    929  f36c							;----------------------------End Main Routines----------------------------
    930  f36c							;-------------------------------------------------------------------------
    931  f36c
    932  f36c
    933  f36c							;*************************************************************************
    934  f36c
    935  f36c							;-------------------------------------------------------------------------
    936  f36c							;----------------------Begin Subroutines----------------------------------
    937  f36c							;-------------------------------------------------------------------------
    938  f36c
    939  f36c
    940  f36c
    941  f36c
    942  f36c				   KernelCleanupSubroutine
    943  f36c
    944  f36c		       a2 04		      ldx	#4
    945  f36e				   AdjustYValuesDownLoop
    946  f36e		       b5 8e		      lda	NewSpriteY,X
    947  f370		       38		      sec
    948  f371		       e9 02		      sbc	#2
    949  f373		       95 8e		      sta	NewSpriteY,X
    950  f375		       ca		      dex
    951  f376		       10 f6		      bpl	AdjustYValuesDownLoop
    952  f378
    953  f378
      0  f378					      RETURN
      1  f378					      ifnconst	bankswitch
      2  f378		       60		      rts
      3  f379				  -	      else
      4  f379				  -	      jmp	BS_return
      5  f379					      endif
    955  f379							;rts
    956  f379
    957  f379				   SetupP1Subroutine
    958  f379							; flickersort algorithm
    959  f379							; count 4-0
    960  f379							; table2=table1 (?)
    961  f379							; detect overlap of sprites in table 2
    962  f379							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
    963  f379							; if no overlap, do regular sort in table 2 and table 1
    964  f379				   fsstart
    965  f379		       a2 ff		      ldx	#255
    966  f37b				   copytable
    967  f37b		       e8		      inx
    968  f37c		       b5 f1		      lda	spritesort,x
    969  f37e		       95 9d		      sta	SpriteGfxIndex,x
    970  f380		       e0 04		      cpx	#4
    971  f382		       d0 f7		      bne	copytable
    972  f384
    973  f384		       86 cd		      stx	temp3	; highest displayed sprite
    974  f386		       ca		      dex
    975  f387		       86 cc		      stx	temp2
    976  f389				   sortloop
    977  f389		       a6 cc		      ldx	temp2
    978  f38b		       b5 f1		      lda	spritesort,x
    979  f38d		       aa		      tax
    980  f38e		       b5 8e		      lda	NewSpriteY,x
    981  f390		       85 cb		      sta	temp1
    982  f392
    983  f392		       a6 cc		      ldx	temp2
    984  f394		       b5 f2		      lda	spritesort+1,x
    985  f396		       aa		      tax
    986  f397		       b5 8e		      lda	NewSpriteY,x
    987  f399		       38		      sec
    988  f39a		       18		      clc
    989  f39b		       e5 cb		      sbc	temp1
    990  f39d		       90 0e		      bcc	largerXislower
    991  f39f
    992  f39f							; larger x is higher (A>=temp1)
    993  f39f		       d5 b1		      cmp	spriteheight,x
    994  f3a1		       b0 2f		      bcs	countdown
    995  f3a3							; overlap with x+1>x
    996  f3a3							; 
    997  f3a3							; stick x at end of gfxtable, dec counter
    998  f3a3				   overlapping
    999  f3a3		       c6 cd		      dec	temp3
   1000  f3a5		       a6 cc		      ldx	temp2
   1001  f3a7							; inx
   1002  f3a7		       20 e6 f3 	      jsr	shiftnumbers
   1003  f3aa		       4c c8 f3 	      jmp	skipswapGfxtable
   1004  f3ad
   1005  f3ad				   largerXislower		; (temp1>A)
   1006  f3ad		       a8		      tay
   1007  f3ae		       a6 cc		      ldx	temp2
   1008  f3b0		       b5 f1		      lda	spritesort,x
   1009  f3b2		       aa		      tax
   1010  f3b3		       98		      tya
   1011  f3b4		       49 ff		      eor	#$FF
   1012  f3b6		       e9 01		      sbc	#1
   1013  f3b8		       90 e9		      bcc	overlapping
   1014  f3ba		       d5 b1		      cmp	spriteheight,x
   1015  f3bc		       b0 0a		      bcs	notoverlapping
   1016  f3be
   1017  f3be		       c6 cd		      dec	temp3
   1018  f3c0		       a6 cc		      ldx	temp2
   1019  f3c2							; inx
   1020  f3c2		       20 e6 f3 	      jsr	shiftnumbers
   1021  f3c5		       4c c8 f3 	      jmp	skipswapGfxtable
   1022  f3c8				   notoverlapping
   1023  f3c8							; ldx temp2 ; swap display table
   1024  f3c8							; ldy SpriteGfxIndex+1,x
   1025  f3c8							; lda SpriteGfxIndex,x
   1026  f3c8							; sty SpriteGfxIndex,x
   1027  f3c8							; sta SpriteGfxIndex+1,x 
   1028  f3c8
   1029  f3c8				   skipswapGfxtable
   1030  f3c8		       a6 cc		      ldx	temp2	; swap sort table
   1031  f3ca		       b4 f2		      ldy	spritesort+1,x
   1032  f3cc		       b5 f1		      lda	spritesort,x
   1033  f3ce		       94 f1		      sty	spritesort,x
   1034  f3d0		       95 f2		      sta	spritesort+1,x
   1035  f3d2
   1036  f3d2				   countdown
   1037  f3d2		       c6 cc		      dec	temp2
   1038  f3d4		       10 b3		      bpl	sortloop
   1039  f3d6
   1040  f3d6				   checktoohigh
   1041  f3d6		       a6 cd		      ldx	temp3
   1042  f3d8		       b5 9d		      lda	SpriteGfxIndex,x
   1043  f3da		       aa		      tax
   1044  f3db		       b5 8e		      lda	NewSpriteY,x
   1045  f3dd				  -	      ifconst	screenheight
   1046  f3dd				  -	      cmp	#screenheight-3
   1047  f3dd					      else
   1048  f3dd		       c9 55		      cmp	#$55
   1049  f3df					      endif
   1050  f3df		       90 04		      bcc	nonetoohigh
   1051  f3e1		       c6 cd		      dec	temp3
   1052  f3e3		       d0 f1		      bne	checktoohigh
   1053  f3e5
   1054  f3e5				   nonetoohigh
   1055  f3e5		       60		      rts
   1056  f3e6
   1057  f3e6
   1058  f3e6				   shiftnumbers
   1059  f3e6							; stick current x at end, shift others down
   1060  f3e6							; if x=4: don't do anything
   1061  f3e6							; if x=3: swap 3 and 4
   1062  f3e6							; if x=2: 2=3, 3=4, 4=2
   1063  f3e6							; if x=1: 1=2, 2=3, 3=4, 4=1
   1064  f3e6							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   1065  f3e6							; ldy SpriteGfxIndex,x
   1066  f3e6				   swaploop
   1067  f3e6		       e0 04		      cpx	#4
   1068  f3e8		       f0 08		      beq	shiftdone
   1069  f3ea		       b5 9e		      lda	SpriteGfxIndex+1,x
   1070  f3ec		       95 9d		      sta	SpriteGfxIndex,x
   1071  f3ee		       e8		      inx
   1072  f3ef		       4c e6 f3 	      jmp	swaploop
   1073  f3f2				   shiftdone
   1074  f3f2							; sty SpriteGfxIndex,x
   1075  f3f2		       60		      rts
   1076  f3f3
   1077  f3f3				  -	      ifconst	debugscore
   1078  f3f3				  -debugcycles
   1079  f3f3				  -	      ldx	#14
   1080  f3f3				  -	      lda	INTIM	; display # cycles left in the score
   1081  f3f3				  -
   1082  f3f3				  -	      ifconst	mincycles
   1083  f3f3				  -	      lda	mincycles
   1084  f3f3				  -	      cmp	INTIM
   1085  f3f3				  -	      lda	mincycles
   1086  f3f3				  -	      bcc	nochange
   1087  f3f3				  -	      lda	INTIM
   1088  f3f3				  -	      sta	mincycles
   1089  f3f3				  -nochange
   1090  f3f3				  -	      endif
   1091  f3f3				  -
   1092  f3f3				  -			;   cmp #$2B
   1093  f3f3				  -			;   bcs no_cycles_left
   1094  f3f3				  -	      bmi	cycles_left
   1095  f3f3				  -	      ldx	#64
   1096  f3f3				  -	      eor	#$ff	;make negative
   1097  f3f3				  -cycles_left
   1098  f3f3				  -	      stx	scorecolor
   1099  f3f3				  -	      and	#$7f	; clear sign bit
   1100  f3f3				  -	      tax
   1101  f3f3				  -	      lda	scorebcd,x
   1102  f3f3				  -	      sta	score+2
   1103  f3f3				  -	      lda	scorebcd1,x
   1104  f3f3				  -	      sta	score+1
   1105  f3f3				  -	      rts
   1106  f3f3				  -scorebcd
   1107  f3f3				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   1108  f3f3				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   1109  f3f3				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   1110  f3f3				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   1111  f3f3				  -scorebcd1
   1112  f3f3				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   1113  f3f3				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   1114  f3f3				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   1115  f3f3				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   1116  f3f3					      endif
   1117  f3f3							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1118  f3f3
   1119  f3f3				   start
   1120  f3f3		       78		      sei
   1121  f3f4		       d8		      cld
   1122  f3f5		       a0 00		      ldy	#0
   1123  f3f7		       a5 d0		      lda	$D0
   1124  f3f9		       c9 2c		      cmp	#$2C	;check RAM location #1
   1125  f3fb		       d0 07		      bne	MachineIs2600
   1126  f3fd		       a5 d1		      lda	$D1
   1127  f3ff		       c9 a9		      cmp	#$A9	;check RAM location #2
   1128  f401		       d0 01		      bne	MachineIs2600
   1129  f403		       88		      dey
   1130  f404				   MachineIs2600
   1131  f404		       a2 00		      ldx	#0
   1132  f406		       8a		      txa
   1133  f407				   clearmem
   1134  f407		       e8		      inx
   1135  f408		       9a		      txs
   1136  f409		       48		      pha
   1137  f40a		       d0 fb		      bne	clearmem
   1138  f40c		       84 cb		      sty	temp1
   1139  f40e				  -	      ifnconst	multisprite
   1140  f40e				  -	      ifconst	pfrowheight
   1141  f40e				  -	      lda	#pfrowheight
   1142  f40e				  -	      else
   1143  f40e				  -	      ifconst	pfres
   1144  f40e				  -	      lda	#(96/pfres)
   1145  f40e				  -	      else
   1146  f40e				  -	      lda	#8
   1147  f40e				  -	      endif
   1148  f40e				  -	      endif
   1149  f40e				  -	      sta	playfieldpos
   1150  f40e					      endif
   1151  f40e		       a2 05		      ldx	#5
   1152  f410				   initscore
   1153  f410		       a9 9c		      lda	#<scoretable
   1154  f412		       95 c5		      sta	scorepointers,x
   1155  f414		       ca		      dex
   1156  f415		       10 f9		      bpl	initscore
   1157  f417		       a9 01		      lda	#1
   1158  f419		       85 0a		      sta	CTRLPF
   1159  f41b		       0d 84 02 	      ora	INTIM
   1160  f41e		       85 d6		      sta	rand
   1161  f420
   1162  f420					      ifconst	multisprite
   1163  f420		       20 1f f0 	      jsr	multisprite_setup
   1164  f423					      endif
   1165  f423
   1166  f423					      ifnconst	bankswitch
   1167  f423		       4c 30 f4 	      jmp	game
   1168  f426				  -	      else
   1169  f426				  -	      lda	#>(game-1)
   1170  f426				  -	      pha
   1171  f426				  -	      lda	#<(game-1)
   1172  f426				  -	      pha
   1173  f426				  -	      pha
   1174  f426				  -	      pha
   1175  f426				  -	      ldx	#1
   1176  f426				  -	      jmp	BS_jsr
   1177  f426					      endif
   1178  f426							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1179  f426
   1180  f426							;standard routines needed for pretty much all games
   1181  f426							; just the random number generator is left - maybe we should remove this asm file altogether?
   1182  f426							; repositioning code and score pointer setup moved to overscan
   1183  f426							; read switches, joysticks now compiler generated (more efficient)
   1184  f426
   1185  f426				   randomize
   1186  f426		       a5 d6		      lda	rand
   1187  f428		       4a		      lsr
   1188  f429				  -	      ifconst	rand16
   1189  f429				  -	      rol	rand16
   1190  f429					      endif
   1191  f429		       90 02		      bcc	noeor
   1192  f42b		       49 b4		      eor	#$B4
   1193  f42d				   noeor
   1194  f42d		       85 d6		      sta	rand
   1195  f42f				  -	      ifconst	rand16
   1196  f42f				  -	      eor	rand16
   1197  f42f					      endif
      0  f42f					      RETURN
      1  f42f					      ifnconst	bankswitch
      2  f42f		       60		      rts
      3  f430				  -	      else
      4  f430				  -	      jmp	BS_return
      5  f430					      endif
   1199  f430				   game
   1200  f430				   .L00 		;  set kernel multisprite
   1201  f430
   1202  f430				   .
   1203  f430							; 
   1204  f430
   1205  f430				   ._ReiniciarNivel
   1206  f430							; _ReiniciarNivel
   1207  f430
   1208  f430				   .
   1209  f430							; 
   1210  f430
   1211  f430				   .L01 		;  if n = 0 then playfield:
   1212  f430
   1213  f430		       a5 e4		      LDA	n
   1214  f432		       c9 00		      CMP	#0
   1215  f434		       d0 10		      BNE	.skipL01
   1216  f436				   .condpart0
   1217  f436		       a9 00		      LDA	#<PF1_data0
   1218  f438		       85 bb		      STA	PF1pointer
   1219  f43a		       a9 f9		      LDA	#>PF1_data0
   1220  f43c		       85 bc		      STA	PF1pointer+1
   1221  f43e		       a9 0b		      LDA	#<PF2_data0
   1222  f440		       85 bd		      STA	PF2pointer
   1223  f442		       a9 f9		      LDA	#>PF2_data0
   1224  f444		       85 be		      STA	PF2pointer+1
   1225  f446				   .skipL01
   1226  f446				   .
   1227  f446							; 
   1228  f446
   1229  f446				   .L02 		;  if n = 1 then playfield:
   1230  f446
   1231  f446		       a5 e4		      LDA	n
   1232  f448		       c9 01		      CMP	#1
   1233  f44a		       d0 10		      BNE	.skipL02
   1234  f44c				   .condpart1
   1235  f44c		       a9 16		      LDA	#<PF1_data1
   1236  f44e		       85 bb		      STA	PF1pointer
   1237  f450		       a9 f9		      LDA	#>PF1_data1
   1238  f452		       85 bc		      STA	PF1pointer+1
   1239  f454		       a9 21		      LDA	#<PF2_data1
   1240  f456		       85 bd		      STA	PF2pointer
   1241  f458		       a9 f9		      LDA	#>PF2_data1
   1242  f45a		       85 be		      STA	PF2pointer+1
   1243  f45c				   .skipL02
   1244  f45c				   .
   1245  f45c							; 
   1246  f45c
   1247  f45c				   .L03 		;  COLUPF  =  28
   1248  f45c
   1249  f45c		       a9 1c		      LDA	#28
   1250  f45e		       85 08		      STA	COLUPF
   1251  f460				   .
   1252  f460							; 
   1253  f460
   1254  f460				   .L04 		;  x = 60
   1255  f460
   1256  f460		       a9 3c		      LDA	#60
   1257  f462		       85 ee		      STA	x
   1258  f464				   .L05 		;  y = 75
   1259  f464
   1260  f464		       a9 4b		      LDA	#75
   1261  f466		       85 ef		      STA	y
   1262  f468				   .
   1263  f468							; 
   1264  f468
   1265  f468				   .L06 		;  player3x = 160
   1266  f468
   1267  f468		       a9 a0		      LDA	#160
   1268  f46a		       85 87		      STA	player3x
   1269  f46c				   .L07 		;  player3y = 50
   1270  f46c
   1271  f46c		       a9 32		      LDA	#50
   1272  f46e		       85 90		      STA	player3y
   1273  f470				   .
   1274  f470							; 
   1275  f470
   1276  f470				   .L08 		;  i = 1
   1277  f470
   1278  f470		       a9 01		      LDA	#1
   1279  f472		       85 df		      STA	i
   1280  f474				   .L09 		;  j = 1
   1281  f474
   1282  f474		       a9 01		      LDA	#1
   1283  f476		       85 e0		      STA	j
   1284  f478				   .
   1285  f478							; 
   1286  f478
   1287  f478				   .L010		;  dim sounda	=  s
   1288  f478
   1289  f478				   .L011		;  dim soundb	=  r
   1290  f478
   1291  f478				   .
   1292  f478							; 
   1293  f478
   1294  f478				   .L012		;  sounda  =  0
   1295  f478
   1296  f478		       a9 00		      LDA	#0
   1297  f47a		       85 e9		      STA	sounda
   1298  f47c				   .L013		;  soundb  =  0
   1299  f47c
   1300  f47c		       a9 00		      LDA	#0
   1301  f47e		       85 e8		      STA	soundb
   1302  f480				   .
   1303  f480							; 
   1304  f480
   1305  f480				   .L014		;  pfheight = 7
   1306  f480
   1307  f480		       a9 07		      LDA	#7
   1308  f482		       85 c4		      STA	pfheight
   1309  f484				   .
   1310  f484							; 
   1311  f484
   1312  f484				   .L015		;  scorecolor	=  14
   1313  f484
   1314  f484		       a9 0e		      LDA	#14
   1315  f486		       85 d5		      STA	scorecolor
   1316  f488				   .
   1317  f488							; 
   1318  f488
   1319  f488				   .main
   1320  f488							; main
   1321  f488
   1322  f488				   .
   1323  f488							; 
   1324  f488
   1325  f488				   .L016		;  COLUP3 = 50
   1326  f488
   1327  f488		       a9 32		      LDA	#50
   1328  f48a		       85 9a		      STA	COLUP3
   1329  f48c				   .L017		;  COLUP0 = 155
   1330  f48c
   1331  f48c		       a9 9b		      LDA	#155
   1332  f48e		       85 06		      STA	COLUP0
   1333  f490				   .L018		;  COLUP2 = 190
   1334  f490
   1335  f490		       a9 be		      LDA	#190
   1336  f492		       85 99		      STA	COLUP2
   1337  f494				   .
   1338  f494							; 
   1339  f494
   1340  f494				   .L019		;  COLUBK = 0
   1341  f494
   1342  f494		       a9 00		      LDA	#0
   1343  f496		       85 09		      STA	COLUBK
   1344  f498				   .
   1345  f498							; 
   1346  f498
   1347  f498				   .L020		;  if f = 0  ||  f = 11 then player0:
   1348  f498
   1349  f498		       a5 dc		      LDA	f
   1350  f49a		       c9 00		      CMP	#0
   1351  f49c		       d0 03		      BNE	.skipL020
   1352  f49e				   .condpart2
   1353  f49e		       4c a7 f4 	      jmp	.condpart3
   1354  f4a1				   .skipL020
   1355  f4a1		       a5 dc		      LDA	f
   1356  f4a3		       c9 0b		      CMP	#11
   1357  f4a5		       d0 0c		      BNE	.skip0OR
   1358  f4a7				   .condpart3
   1359  f4a7		       a2 dd		      LDX	#<player3then_0
   1360  f4a9		       86 a2		      STX	player0pointerlo
   1361  f4ab		       a9 f8		      LDA	#>player3then_0
   1362  f4ad		       85 a3		      STA	player0pointerhi
   1363  f4af		       a9 09		      LDA	#9
   1364  f4b1		       85 b0		      STA	player0height
   1365  f4b3				   .skip0OR
   1366  f4b3				   .
   1367  f4b3							; 
   1368  f4b3
   1369  f4b3				   .L021		;  if f = 1 then player0:
   1370  f4b3
   1371  f4b3		       a5 dc		      LDA	f
   1372  f4b5		       c9 01		      CMP	#1
   1373  f4b7		       d0 0c		      BNE	.skipL021
   1374  f4b9				   .condpart4
   1375  f4b9		       a2 e6		      LDX	#<player4then_0
   1376  f4bb		       86 a2		      STX	player0pointerlo
   1377  f4bd		       a9 f8		      LDA	#>player4then_0
   1378  f4bf		       85 a3		      STA	player0pointerhi
   1379  f4c1		       a9 0a		      LDA	#10
   1380  f4c3		       85 b0		      STA	player0height
   1381  f4c5				   .skipL021
   1382  f4c5				   .
   1383  f4c5							; 
   1384  f4c5
   1385  f4c5				   .L022		;  player3:
   1386  f4c5
   1387  f4c5		       a2 f0		      LDX	#<playerL022_3
   1388  f4c7		       86 a8		      STX	player3pointerlo
   1389  f4c9		       a9 f8		      LDA	#>playerL022_3
   1390  f4cb		       85 ad		      STA	player3pointerhi
   1391  f4cd		       a9 09		      LDA	#9
   1392  f4cf		       85 b3		      STA	player3height
   1393  f4d1				   .
   1394  f4d1							; 
   1395  f4d1
   1396  f4d1				   .L023		;  player2:
   1397  f4d1
   1398  f4d1		       a2 f8		      LDX	#<playerL023_2
   1399  f4d3		       86 a7		      STX	player2pointerlo
   1400  f4d5		       a9 f8		      LDA	#>playerL023_2
   1401  f4d7		       85 ac		      STA	player2pointerhi
   1402  f4d9		       a9 09		      LDA	#9
   1403  f4db		       85 b2		      STA	player2height
   1404  f4dd				   .
   1405  f4dd							; 
   1406  f4dd
   1407  f4dd				   .L024		;  player0x = x
   1408  f4dd
   1409  f4dd		       a5 ee		      LDA	x
   1410  f4df		       85 84		      STA	player0x
   1411  f4e1				   .L025		;  player0y = y
   1412  f4e1
   1413  f4e1		       a5 ef		      LDA	y
   1414  f4e3		       85 8d		      STA	player0y
   1415  f4e5				   .
   1416  f4e5							; 
   1417  f4e5
   1418  f4e5				   .L026		;  drawscreen
   1419  f4e5
   1420  f4e5		       20 3a f0 	      jsr	drawscreen
   1421  f4e8				   .
   1422  f4e8							; 
   1423  f4e8
   1424  f4e8				   .L027		;  if t = 0 then g = 0
   1425  f4e8
   1426  f4e8		       a5 ea		      LDA	t
   1427  f4ea		       c9 00		      CMP	#0
   1428  f4ec		       d0 04		      BNE	.skipL027
   1429  f4ee				   .condpart5
   1430  f4ee		       a9 00		      LDA	#0
   1431  f4f0		       85 dd		      STA	g
   1432  f4f2				   .skipL027
   1433  f4f2				   .
   1434  f4f2							; 
   1435  f4f2
   1436  f4f2				   .L028		;  if joy0right  ||  joy0left then f = f + 1 else f = 0
   1437  f4f2
   1438  f4f2		       2c 80 02 	      bit	SWCHA
   1439  f4f5		       30 03		      BMI	.skipL028
   1440  f4f7				   .condpart6
   1441  f4f7		       4c ff f4 	      jmp	.condpart7
   1442  f4fa				   .skipL028
   1443  f4fa		       2c 80 02 	      bit	SWCHA
   1444  f4fd		       70 05		      BVS	.skip1OR
   1445  f4ff				   .condpart7
   1446  f4ff		       e6 dc		      INC	f
   1447  f501		       4c 08 f5 	      jmp	.skipelse0
   1448  f504				   .skip1OR
   1449  f504		       a9 00		      LDA	#0
   1450  f506		       85 dc		      STA	f
   1451  f508				   .skipelse0
   1452  f508				   .
   1453  f508							; 
   1454  f508
   1455  f508				   .L029		;  if joy0up  &&  t = 0  &&  u = 0 then t = 30
   1456  f508
   1457  f508		       a9 10		      lda	#$10
   1458  f50a		       2c 80 02 	      bit	SWCHA
   1459  f50d		       d0 10		      BNE	.skipL029
   1460  f50f				   .condpart8
   1461  f50f		       a5 ea		      LDA	t
   1462  f511		       c9 00		      CMP	#0
   1463  f513		       d0 0a		      BNE	.skip8then
   1464  f515				   .condpart9
   1465  f515		       a5 eb		      LDA	u
   1466  f517		       c9 00		      CMP	#0
   1467  f519		       d0 04		      BNE	.skip9then
   1468  f51b				   .condpart10
   1469  f51b		       a9 1e		      LDA	#30
   1470  f51d		       85 ea		      STA	t
   1471  f51f				   .skip9then
   1472  f51f				   .skip8then
   1473  f51f				   .skipL029
   1474  f51f				   .L030		;  if t > 0 then t = t - 1  :	g = 1
   1475  f51f
   1476  f51f		       a9 00		      LDA	#0
   1477  f521		       c5 ea		      CMP	t
   1478  f523		       b0 06		      BCS	.skipL030
   1479  f525				   .condpart11
   1480  f525		       c6 ea		      DEC	t
   1481  f527		       a9 01		      LDA	#1
   1482  f529		       85 dd		      STA	g
   1483  f52b				   .skipL030
   1484  f52b				   .
   1485  f52b							; 
   1486  f52b
   1487  f52b				   .L031		;  if !joy0right then goto _IgnorarDerecha
   1488  f52b
   1489  f52b		       2c 80 02 	      bit	SWCHA
   1490  f52e		       10 03		      BPL	.skipL031
   1491  f530				   .condpart12
   1492  f530		       4c 84 f5 	      jmp	._IgnorarDerecha
   1493  f533
   1494  f533				   .skipL031
   1495  f533				   .L032		;  temp5  =   ( y + 1 - 11 )  / 8
   1496  f533
   1497  f533							; complex statement detected
   1498  f533		       a5 ef		      LDA	y
   1499  f535		       18		      CLC
   1500  f536		       69 01		      ADC	#1
   1501  f538		       38		      SEC
   1502  f539		       e9 0b		      SBC	#11
   1503  f53b		       4a		      lsr
   1504  f53c		       4a		      lsr
   1505  f53d		       4a		      lsr
   1506  f53e		       85 cf		      STA	temp5
   1507  f540				   .
   1508  f540							; 
   1509  f540
   1510  f540				   .L033		;  temp6  =   ( x - 9 )  / 4
   1511  f540
   1512  f540							; complex statement detected
   1513  f540		       a5 ee		      LDA	x
   1514  f542		       38		      SEC
   1515  f543		       e9 09		      SBC	#9
   1516  f545		       4a		      lsr
   1517  f546		       4a		      lsr
   1518  f547		       85 d0		      STA	temp6
   1519  f549				   .
   1520  f549							; 
   1521  f549
   1522  f549				   .L034		;  if temp6  <  34 then if !pfread ( temp6 , temp5 )  then goto _IgnorarDerecha
   1523  f549
   1524  f549		       a5 d0		      LDA	temp6
   1525  f54b		       c9 22		      CMP	#34
   1526  f54d		       b0 0c		      BCS	.skipL034
   1527  f54f				   .condpart13
   1528  f54f		       a5 d0		      LDA	temp6
   1529  f551		       a4 cf		      LDY	temp5
   1530  f553		       20 b9 f8 	      jsr	pfread
   1531  f556		       f0 03		      BEQ	.skip13then
   1532  f558				   .condpart14
   1533  f558		       4c 84 f5 	      jmp	._IgnorarDerecha
   1534  f55b
   1535  f55b				   .skip13then
   1536  f55b				   .skipL034
   1537  f55b				   .
   1538  f55b							; 
   1539  f55b
   1540  f55b				   .L035		;  temp3  =   ( y + 8 - 11 )  / 8
   1541  f55b
   1542  f55b							; complex statement detected
   1543  f55b		       a5 ef		      LDA	y
   1544  f55d		       18		      CLC
   1545  f55e		       69 08		      ADC	#8
   1546  f560		       38		      SEC
   1547  f561		       e9 0b		      SBC	#11
   1548  f563		       4a		      lsr
   1549  f564		       4a		      lsr
   1550  f565		       4a		      lsr
   1551  f566		       85 cd		      STA	temp3
   1552  f568				   .
   1553  f568							; 
   1554  f568
   1555  f568				   .L036		;  if temp6  <  34 then if !pfread ( temp6 , temp3 )  then goto _IgnorarDerecha
   1556  f568
   1557  f568		       a5 d0		      LDA	temp6
   1558  f56a		       c9 22		      CMP	#34
   1559  f56c		       b0 0c		      BCS	.skipL036
   1560  f56e				   .condpart15
   1561  f56e		       a5 d0		      LDA	temp6
   1562  f570		       a4 cd		      LDY	temp3
   1563  f572		       20 b9 f8 	      jsr	pfread
   1564  f575		       f0 03		      BEQ	.skip15then
   1565  f577				   .condpart16
   1566  f577		       4c 84 f5 	      jmp	._IgnorarDerecha
   1567  f57a
   1568  f57a				   .skip15then
   1569  f57a				   .skipL036
   1570  f57a				   .
   1571  f57a							; 
   1572  f57a
   1573  f57a				   .L037		;  d = 1
   1574  f57a
   1575  f57a		       a9 01		      LDA	#1
   1576  f57c		       85 da		      STA	d
   1577  f57e				   .L038		;  x = x + 1
   1578  f57e
   1579  f57e		       e6 ee		      INC	x
   1580  f580				   .L039		;  REFP0 = 0
   1581  f580
   1582  f580		       a9 00		      LDA	#0
   1583  f582		       85 0b		      STA	REFP0
   1584  f584				   .
   1585  f584							; 
   1586  f584
   1587  f584				   ._IgnorarDerecha
   1588  f584							; _IgnorarDerecha
   1589  f584
   1590  f584				   .
   1591  f584							; 
   1592  f584
   1593  f584				   .L040		;  if !joy0left then goto _IgnorarIzquierda
   1594  f584
   1595  f584		       2c 80 02 	      bit	SWCHA
   1596  f587		       50 03		      BVC	.skipL040
   1597  f589				   .condpart17
   1598  f589		       4c dd f5 	      jmp	._IgnorarIzquierda
   1599  f58c
   1600  f58c				   .skipL040
   1601  f58c				   .L041		;  temp5  =   ( y + 1 - 11 )  / 8
   1602  f58c
   1603  f58c							; complex statement detected
   1604  f58c		       a5 ef		      LDA	y
   1605  f58e		       18		      CLC
   1606  f58f		       69 01		      ADC	#1
   1607  f591		       38		      SEC
   1608  f592		       e9 0b		      SBC	#11
   1609  f594		       4a		      lsr
   1610  f595		       4a		      lsr
   1611  f596		       4a		      lsr
   1612  f597		       85 cf		      STA	temp5
   1613  f599				   .
   1614  f599							; 
   1615  f599
   1616  f599				   .L042		;  temp6  =   ( x - 18 )  / 4
   1617  f599
   1618  f599							; complex statement detected
   1619  f599		       a5 ee		      LDA	x
   1620  f59b		       38		      SEC
   1621  f59c		       e9 12		      SBC	#18
   1622  f59e		       4a		      lsr
   1623  f59f		       4a		      lsr
   1624  f5a0		       85 d0		      STA	temp6
   1625  f5a2				   .
   1626  f5a2							; 
   1627  f5a2
   1628  f5a2				   .L043		;  if temp6  <  34 then if !pfread ( temp6 , temp5 )  then goto _IgnorarIzquierda
   1629  f5a2
   1630  f5a2		       a5 d0		      LDA	temp6
   1631  f5a4		       c9 22		      CMP	#34
   1632  f5a6		       b0 0c		      BCS	.skipL043
   1633  f5a8				   .condpart18
   1634  f5a8		       a5 d0		      LDA	temp6
   1635  f5aa		       a4 cf		      LDY	temp5
   1636  f5ac		       20 b9 f8 	      jsr	pfread
   1637  f5af		       f0 03		      BEQ	.skip18then
   1638  f5b1				   .condpart19
   1639  f5b1		       4c dd f5 	      jmp	._IgnorarIzquierda
   1640  f5b4
   1641  f5b4				   .skip18then
   1642  f5b4				   .skipL043
   1643  f5b4				   .
   1644  f5b4							; 
   1645  f5b4
   1646  f5b4				   .L044		;  temp3  =   ( y + 8 - 11 )  / 8
   1647  f5b4
   1648  f5b4							; complex statement detected
   1649  f5b4		       a5 ef		      LDA	y
   1650  f5b6		       18		      CLC
   1651  f5b7		       69 08		      ADC	#8
   1652  f5b9		       38		      SEC
   1653  f5ba		       e9 0b		      SBC	#11
   1654  f5bc		       4a		      lsr
   1655  f5bd		       4a		      lsr
   1656  f5be		       4a		      lsr
   1657  f5bf		       85 cd		      STA	temp3
   1658  f5c1				   .
   1659  f5c1							; 
   1660  f5c1
   1661  f5c1				   .L045		;  if temp6  <  34 then if !pfread ( temp6 , temp3 )  then goto _IgnorarIzquierda
   1662  f5c1
   1663  f5c1		       a5 d0		      LDA	temp6
   1664  f5c3		       c9 22		      CMP	#34
   1665  f5c5		       b0 0c		      BCS	.skipL045
   1666  f5c7				   .condpart20
   1667  f5c7		       a5 d0		      LDA	temp6
   1668  f5c9		       a4 cd		      LDY	temp3
   1669  f5cb		       20 b9 f8 	      jsr	pfread
   1670  f5ce		       f0 03		      BEQ	.skip20then
   1671  f5d0				   .condpart21
   1672  f5d0		       4c dd f5 	      jmp	._IgnorarIzquierda
   1673  f5d3
   1674  f5d3				   .skip20then
   1675  f5d3				   .skipL045
   1676  f5d3				   .
   1677  f5d3							; 
   1678  f5d3
   1679  f5d3				   .L046		;  d = 0
   1680  f5d3
   1681  f5d3		       a9 00		      LDA	#0
   1682  f5d5		       85 da		      STA	d
   1683  f5d7				   .L047		;  x = x - 1
   1684  f5d7
   1685  f5d7		       c6 ee		      DEC	x
   1686  f5d9				   .L048		;  REFP0 = 8
   1687  f5d9
   1688  f5d9		       a9 08		      LDA	#8
   1689  f5db		       85 0b		      STA	REFP0
   1690  f5dd				   .
   1691  f5dd							; 
   1692  f5dd
   1693  f5dd				   ._IgnorarIzquierda
   1694  f5dd							; _IgnorarIzquierda
   1695  f5dd
   1696  f5dd				   .
   1697  f5dd							; 
   1698  f5dd
   1699  f5dd				   .L049		;  if !g = 0 then goto _IgnorarArriba
   1700  f5dd
   1701  f5dd		       a5 dd		      LDA	g
   1702  f5df		       c9 00		      CMP	#0
   1703  f5e1		       d0 03		      BNE	.skipL049
   1704  f5e3				   .condpart22
   1705  f5e3		       4c 50 f6 	      jmp	._IgnorarArriba
   1706  f5e6
   1707  f5e6				   .skipL049
   1708  f5e6				   .
   1709  f5e6							; 
   1710  f5e6
   1711  f5e6				   .L050		;  temp5  =   ( x - 10 )  / 4
   1712  f5e6
   1713  f5e6							; complex statement detected
   1714  f5e6		       a5 ee		      LDA	x
   1715  f5e8		       38		      SEC
   1716  f5e9		       e9 0a		      SBC	#10
   1717  f5eb		       4a		      lsr
   1718  f5ec		       4a		      lsr
   1719  f5ed		       85 cf		      STA	temp5
   1720  f5ef				   .
   1721  f5ef							; 
   1722  f5ef
   1723  f5ef				   .L051		;  temp6  =   ( y + 9 - 11 )  / 8
   1724  f5ef
   1725  f5ef							; complex statement detected
   1726  f5ef		       a5 ef		      LDA	y
   1727  f5f1		       18		      CLC
   1728  f5f2		       69 09		      ADC	#9
   1729  f5f4		       38		      SEC
   1730  f5f5		       e9 0b		      SBC	#11
   1731  f5f7		       4a		      lsr
   1732  f5f8		       4a		      lsr
   1733  f5f9		       4a		      lsr
   1734  f5fa		       85 d0		      STA	temp6
   1735  f5fc				   .
   1736  f5fc							; 
   1737  f5fc
   1738  f5fc				   .L052		;  if temp5  <  34 then if !pfread ( temp5 , temp6 )  then t = 0  :  goto _IgnorarArriba
   1739  f5fc
   1740  f5fc		       a5 cf		      LDA	temp5
   1741  f5fe		       c9 22		      CMP	#34
   1742  f600		       b0 10		      BCS	.skipL052
   1743  f602				   .condpart23
   1744  f602		       a5 cf		      LDA	temp5
   1745  f604		       a4 d0		      LDY	temp6
   1746  f606		       20 b9 f8 	      jsr	pfread
   1747  f609		       f0 07		      BEQ	.skip23then
   1748  f60b				   .condpart24
   1749  f60b		       a9 00		      LDA	#0
   1750  f60d		       85 ea		      STA	t
   1751  f60f		       4c 50 f6 	      jmp	._IgnorarArriba
   1752  f612
   1753  f612				   .skip23then
   1754  f612				   .skipL052
   1755  f612				   .
   1756  f612							; 
   1757  f612
   1758  f612				   .L053		;  temp4  =   ( x - 17 )  / 4
   1759  f612
   1760  f612							; complex statement detected
   1761  f612		       a5 ee		      LDA	x
   1762  f614		       38		      SEC
   1763  f615		       e9 11		      SBC	#17
   1764  f617		       4a		      lsr
   1765  f618		       4a		      lsr
   1766  f619		       85 ce		      STA	temp4
   1767  f61b				   .
   1768  f61b							; 
   1769  f61b
   1770  f61b				   .L054		;  if temp4  <  34 then if !pfread ( temp4 , temp6 )  then t = 0  :  goto _IgnorarArriba
   1771  f61b
   1772  f61b		       a5 ce		      LDA	temp4
   1773  f61d		       c9 22		      CMP	#34
   1774  f61f		       b0 10		      BCS	.skipL054
   1775  f621				   .condpart25
   1776  f621		       a5 ce		      LDA	temp4
   1777  f623		       a4 d0		      LDY	temp6
   1778  f625		       20 b9 f8 	      jsr	pfread
   1779  f628		       f0 07		      BEQ	.skip25then
   1780  f62a				   .condpart26
   1781  f62a		       a9 00		      LDA	#0
   1782  f62c		       85 ea		      STA	t
   1783  f62e		       4c 50 f6 	      jmp	._IgnorarArriba
   1784  f631
   1785  f631				   .skip25then
   1786  f631				   .skipL054
   1787  f631				   .
   1788  f631							; 
   1789  f631
   1790  f631				   .L055		;  temp3  =  temp5  -	1
   1791  f631
   1792  f631		       a5 cf		      LDA	temp5
   1793  f633		       38		      SEC
   1794  f634		       e9 01		      SBC	#1
   1795  f636		       85 cd		      STA	temp3
   1796  f638				   .
   1797  f638							; 
   1798  f638
   1799  f638				   .L056		;  if temp3  <  34 then if !pfread ( temp3 , temp6 )  then t = 0  :  goto _IgnorarArriba
   1800  f638
   1801  f638		       a5 cd		      LDA	temp3
   1802  f63a		       c9 22		      CMP	#34
   1803  f63c		       b0 10		      BCS	.skipL056
   1804  f63e				   .condpart27
   1805  f63e		       a5 cd		      LDA	temp3
   1806  f640		       a4 d0		      LDY	temp6
   1807  f642		       20 b9 f8 	      jsr	pfread
   1808  f645		       f0 07		      BEQ	.skip27then
   1809  f647				   .condpart28
   1810  f647		       a9 00		      LDA	#0
   1811  f649		       85 ea		      STA	t
   1812  f64b		       4c 50 f6 	      jmp	._IgnorarArriba
   1813  f64e
   1814  f64e				   .skip27then
   1815  f64e				   .skipL056
   1816  f64e				   .
   1817  f64e							; 
   1818  f64e
   1819  f64e				   .L057		;  y = y + 1
   1820  f64e
   1821  f64e		       e6 ef		      INC	y
   1822  f650				   .
   1823  f650							; 
   1824  f650
   1825  f650				   ._IgnorarArriba
   1826  f650							; _IgnorarArriba
   1827  f650
   1828  f650				   .
   1829  f650							; 
   1830  f650
   1831  f650				   .L058		;  if !g = 1 then u = 1  :  goto _IgnorarAbajo
   1832  f650
   1833  f650		       a5 dd		      LDA	g
   1834  f652		       c9 01		      CMP	#1
   1835  f654		       d0 07		      BNE	.skipL058
   1836  f656				   .condpart29
   1837  f656		       a9 01		      LDA	#1
   1838  f658		       85 eb		      STA	u
   1839  f65a		       4c ca f6 	      jmp	._IgnorarAbajo
   1840  f65d
   1841  f65d				   .skipL058
   1842  f65d				   .
   1843  f65d							; 
   1844  f65d
   1845  f65d				   .L059		;  temp5  =   ( x - 10 )  / 4
   1846  f65d
   1847  f65d							; complex statement detected
   1848  f65d		       a5 ee		      LDA	x
   1849  f65f		       38		      SEC
   1850  f660		       e9 0a		      SBC	#10
   1851  f662		       4a		      lsr
   1852  f663		       4a		      lsr
   1853  f664		       85 cf		      STA	temp5
   1854  f666				   .
   1855  f666							; 
   1856  f666
   1857  f666				   .L060		;  temp6  =   ( y - 11 )  / 8
   1858  f666
   1859  f666							; complex statement detected
   1860  f666		       a5 ef		      LDA	y
   1861  f668		       38		      SEC
   1862  f669		       e9 0b		      SBC	#11
   1863  f66b		       4a		      lsr
   1864  f66c		       4a		      lsr
   1865  f66d		       4a		      lsr
   1866  f66e		       85 d0		      STA	temp6
   1867  f670				   .
   1868  f670							; 
   1869  f670
   1870  f670				   .L061		;  if temp5  <  34 then if !pfread ( temp5 , temp6 )  then goto _RevisarArriba
   1871  f670
   1872  f670		       a5 cf		      LDA	temp5
   1873  f672		       c9 22		      CMP	#34
   1874  f674		       b0 0c		      BCS	.skipL061
   1875  f676				   .condpart30
   1876  f676		       a5 cf		      LDA	temp5
   1877  f678		       a4 d0		      LDY	temp6
   1878  f67a		       20 b9 f8 	      jsr	pfread
   1879  f67d		       f0 03		      BEQ	.skip30then
   1880  f67f				   .condpart31
   1881  f67f		       4c bb f6 	      jmp	._RevisarArriba
   1882  f682
   1883  f682				   .skip30then
   1884  f682				   .skipL061
   1885  f682				   .
   1886  f682							; 
   1887  f682
   1888  f682				   .L062		;  temp4  =   ( x - 17 )  / 4
   1889  f682
   1890  f682							; complex statement detected
   1891  f682		       a5 ee		      LDA	x
   1892  f684		       38		      SEC
   1893  f685		       e9 11		      SBC	#17
   1894  f687		       4a		      lsr
   1895  f688		       4a		      lsr
   1896  f689		       85 ce		      STA	temp4
   1897  f68b				   .
   1898  f68b							; 
   1899  f68b
   1900  f68b				   .L063		;  if temp4  <  34 then if !pfread ( temp4 , temp6 )  then goto _RevisarArriba
   1901  f68b
   1902  f68b		       a5 ce		      LDA	temp4
   1903  f68d		       c9 22		      CMP	#34
   1904  f68f		       b0 0c		      BCS	.skipL063
   1905  f691				   .condpart32
   1906  f691		       a5 ce		      LDA	temp4
   1907  f693		       a4 d0		      LDY	temp6
   1908  f695		       20 b9 f8 	      jsr	pfread
   1909  f698		       f0 03		      BEQ	.skip32then
   1910  f69a				   .condpart33
   1911  f69a		       4c bb f6 	      jmp	._RevisarArriba
   1912  f69d
   1913  f69d				   .skip32then
   1914  f69d				   .skipL063
   1915  f69d				   .
   1916  f69d							; 
   1917  f69d
   1918  f69d				   .L064		;  temp3  =  temp5  -	1
   1919  f69d
   1920  f69d		       a5 cf		      LDA	temp5
   1921  f69f		       38		      SEC
   1922  f6a0		       e9 01		      SBC	#1
   1923  f6a2		       85 cd		      STA	temp3
   1924  f6a4				   .
   1925  f6a4							; 
   1926  f6a4
   1927  f6a4				   .L065		;  if temp3  <  34 then if !pfread ( temp3 , temp6 )  then goto _RevisarArriba
   1928  f6a4
   1929  f6a4		       a5 cd		      LDA	temp3
   1930  f6a6		       c9 22		      CMP	#34
   1931  f6a8		       b0 0c		      BCS	.skipL065
   1932  f6aa				   .condpart34
   1933  f6aa		       a5 cd		      LDA	temp3
   1934  f6ac		       a4 d0		      LDY	temp6
   1935  f6ae		       20 b9 f8 	      jsr	pfread
   1936  f6b1		       f0 03		      BEQ	.skip34then
   1937  f6b3				   .condpart35
   1938  f6b3		       4c bb f6 	      jmp	._RevisarArriba
   1939  f6b6
   1940  f6b6				   .skip34then
   1941  f6b6				   .skipL065
   1942  f6b6				   .
   1943  f6b6							; 
   1944  f6b6
   1945  f6b6				   .L066		;  y = y - 1
   1946  f6b6
   1947  f6b6		       c6 ef		      DEC	y
   1948  f6b8				   .
   1949  f6b8							; 
   1950  f6b8
   1951  f6b8				   .L067		;  goto _IgnorarAbajo
   1952  f6b8
   1953  f6b8		       4c ca f6 	      jmp	._IgnorarAbajo
   1954  f6bb
   1955  f6bb				   .
   1956  f6bb							; 
   1957  f6bb
   1958  f6bb				   ._RevisarArriba
   1959  f6bb							; _RevisarArriba
   1960  f6bb
   1961  f6bb				   .
   1962  f6bb							; 
   1963  f6bb
   1964  f6bb				   .L068		;  u = 0
   1965  f6bb
   1966  f6bb		       a9 00		      LDA	#0
   1967  f6bd		       85 eb		      STA	u
   1968  f6bf				   .L069		;  if joy0up then u = 1
   1969  f6bf
   1970  f6bf		       a9 10		      lda	#$10
   1971  f6c1		       2c 80 02 	      bit	SWCHA
   1972  f6c4		       d0 04		      BNE	.skipL069
   1973  f6c6				   .condpart36
   1974  f6c6		       a9 01		      LDA	#1
   1975  f6c8		       85 eb		      STA	u
   1976  f6ca				   .skipL069
   1977  f6ca				   .
   1978  f6ca							; 
   1979  f6ca
   1980  f6ca				   ._IgnorarAbajo
   1981  f6ca							; _IgnorarAbajo
   1982  f6ca
   1983  f6ca				   .
   1984  f6ca							; 
   1985  f6ca
   1986  f6ca				   .L070		;  if joy0fire then p = p + 1 else p = 0
   1987  f6ca
   1988  f6ca		       24 0c		      bit	INPT4
   1989  f6cc		       30 05		      BMI	.skipL070
   1990  f6ce				   .condpart37
   1991  f6ce		       e6 e6		      INC	p
   1992  f6d0		       4c d7 f6 	      jmp	.skipelse1
   1993  f6d3				   .skipL070
   1994  f6d3		       a9 00		      LDA	#0
   1995  f6d5		       85 e6		      STA	p
   1996  f6d7				   .skipelse1
   1997  f6d7				   .
   1998  f6d7							; 
   1999  f6d7
   2000  f6d7				   .L071		;  if joy0fire  &&  d = 0  &&	p = 1 then c = 1  :  ballx = x	:  bally = y - 5  :  sounda  =	5
   2001  f6d7
   2002  f6d7		       24 0c		      bit	INPT4
   2003  f6d9		       30 1f		      BMI	.skipL071
   2004  f6db				   .condpart38
   2005  f6db		       a5 da		      LDA	d
   2006  f6dd		       c9 00		      CMP	#0
   2007  f6df		       d0 19		      BNE	.skip38then
   2008  f6e1				   .condpart39
   2009  f6e1		       a5 e6		      LDA	p
   2010  f6e3		       c9 01		      CMP	#1
   2011  f6e5		       d0 13		      BNE	.skip39then
   2012  f6e7				   .condpart40
   2013  f6e7		       a9 01		      LDA	#1
   2014  f6e9		       85 d9		      STA	c
   2015  f6eb		       a5 ee		      LDA	x
   2016  f6ed		       85 82		      STA	ballx
   2017  f6ef		       a5 ef		      LDA	y
   2018  f6f1		       38		      SEC
   2019  f6f2		       e9 05		      SBC	#5
   2020  f6f4		       85 8c		      STA	bally
   2021  f6f6		       a9 05		      LDA	#5
   2022  f6f8		       85 e9		      STA	sounda
   2023  f6fa				   .skip39then
   2024  f6fa				   .skip38then
   2025  f6fa				   .skipL071
   2026  f6fa				   .L072		;  if joy0fire  &&  d = 1  &&	p = 1 then c = 2  :  ballx = x + 9  :  bally = y - 5  :  sounda  =  5
   2027  f6fa
   2028  f6fa		       24 0c		      bit	INPT4
   2029  f6fc		       30 22		      BMI	.skipL072
   2030  f6fe				   .condpart41
   2031  f6fe		       a5 da		      LDA	d
   2032  f700		       c9 01		      CMP	#1
   2033  f702		       d0 1c		      BNE	.skip41then
   2034  f704				   .condpart42
   2035  f704		       a5 e6		      LDA	p
   2036  f706		       c9 01		      CMP	#1
   2037  f708		       d0 16		      BNE	.skip42then
   2038  f70a				   .condpart43
   2039  f70a		       a9 02		      LDA	#2
   2040  f70c		       85 d9		      STA	c
   2041  f70e		       a5 ee		      LDA	x
   2042  f710		       18		      CLC
   2043  f711		       69 09		      ADC	#9
   2044  f713		       85 82		      STA	ballx
   2045  f715		       a5 ef		      LDA	y
   2046  f717		       38		      SEC
   2047  f718		       e9 05		      SBC	#5
   2048  f71a		       85 8c		      STA	bally
   2049  f71c		       a9 05		      LDA	#5
   2050  f71e		       85 e9		      STA	sounda
   2051  f720				   .skip42then
   2052  f720				   .skip41then
   2053  f720				   .skipL072
   2054  f720				   .
   2055  f720							; 
   2056  f720
   2057  f720				   .L073		;  if sounda  >  0 then sounda  =  sounda  -  1  :  AUDC0  =  4  :  AUDV0  =  4  :  AUDF0  =  sounda else AUDV0  =  0
   2058  f720
   2059  f720		       a9 00		      LDA	#0
   2060  f722		       c5 e9		      CMP	sounda
   2061  f724		       b0 0f		      BCS	.skipL073
   2062  f726				   .condpart44
   2063  f726		       c6 e9		      DEC	sounda
   2064  f728		       a9 04		      LDA	#4
   2065  f72a		       85 15		      STA	AUDC0
   2066  f72c		       85 19		      STA	AUDV0
   2067  f72e		       a5 e9		      LDA	sounda
   2068  f730		       85 17		      STA	AUDF0
   2069  f732		       4c 39 f7 	      jmp	.skipelse2
   2070  f735				   .skipL073
   2071  f735		       a9 00		      LDA	#0
   2072  f737		       85 19		      STA	AUDV0
   2073  f739				   .skipelse2
   2074  f739				   .
   2075  f739							; 
   2076  f739
   2077  f739				   .L074		;  if c = 1 then ballx  =  ballx - 1
   2078  f739
   2079  f739		       a5 d9		      LDA	c
   2080  f73b		       c9 01		      CMP	#1
   2081  f73d		       d0 02		      BNE	.skipL074
   2082  f73f				   .condpart45
   2083  f73f		       c6 82		      DEC	ballx
   2084  f741				   .skipL074
   2085  f741				   .L075		;  if c = 2 then ballx  =  ballx + 1
   2086  f741
   2087  f741		       a5 d9		      LDA	c
   2088  f743		       c9 02		      CMP	#2
   2089  f745		       d0 02		      BNE	.skipL075
   2090  f747				   .condpart46
   2091  f747		       e6 82		      INC	ballx
   2092  f749				   .skipL075
   2093  f749				   .
   2094  f749							; 
   2095  f749
   2096  f749				   .L076		;  if ballx < 0 then c = 0
   2097  f749
   2098  f749		       a5 82		      LDA	ballx
   2099  f74b		       c9 00		      CMP	#0
   2100  f74d		       b0 04		      BCS	.skipL076
   2101  f74f				   .condpart47
   2102  f74f		       a9 00		      LDA	#0
   2103  f751		       85 d9		      STA	c
   2104  f753				   .skipL076
   2105  f753				   .L077		;  if ballx > 160 then c = 0
   2106  f753
   2107  f753		       a9 a0		      LDA	#160
   2108  f755		       c5 82		      CMP	ballx
   2109  f757		       b0 04		      BCS	.skipL077
   2110  f759				   .condpart48
   2111  f759		       a9 00		      LDA	#0
   2112  f75b		       85 d9		      STA	c
   2113  f75d				   .skipL077
   2114  f75d				   .
   2115  f75d							; 
   2116  f75d
   2117  f75d				   .L078		;  if c = 0 then ballx = 0  :	bally = 0
   2118  f75d
   2119  f75d		       a5 d9		      LDA	c
   2120  f75f		       c9 00		      CMP	#0
   2121  f761		       d0 06		      BNE	.skipL078
   2122  f763				   .condpart49
   2123  f763		       a9 00		      LDA	#0
   2124  f765		       85 82		      STA	ballx
   2125  f767		       85 8c		      STA	bally
   2126  f769				   .skipL078
   2127  f769				   .
   2128  f769							; 
   2129  f769
   2130  f769				   .L079		;  if i = 1 then player3x = player3x - 1
   2131  f769
   2132  f769		       a5 df		      LDA	i
   2133  f76b		       c9 01		      CMP	#1
   2134  f76d		       d0 02		      BNE	.skipL079
   2135  f76f				   .condpart50
   2136  f76f		       c6 87		      DEC	player3x
   2137  f771				   .skipL079
   2138  f771				   .L080		;  if i = 1  &&  player3x = 0 then player3x = 160  :  player3y  =   ( rand & 30 )  + 20
   2139  f771
   2140  f771		       a5 df		      LDA	i
   2141  f773		       c9 01		      CMP	#1
   2142  f775		       d0 14		      BNE	.skipL080
   2143  f777				   .condpart51
   2144  f777		       a5 87		      LDA	player3x
   2145  f779		       c9 00		      CMP	#0
   2146  f77b		       d0 0e		      BNE	.skip51then
   2147  f77d				   .condpart52
   2148  f77d		       a9 a0		      LDA	#160
   2149  f77f		       85 87		      STA	player3x
   2150  f781							; complex statement detected
   2151  f781		       20 26 f4 	      jsr	randomize
   2152  f784		       29 1e		      AND	#30
   2153  f786		       18		      CLC
   2154  f787		       69 14		      ADC	#20
   2155  f789		       85 90		      STA	player3y
   2156  f78b				   .skip51then
   2157  f78b				   .skipL080
   2158  f78b				   .
   2159  f78b							; 
   2160  f78b
   2161  f78b				   .
   2162  f78b							; 
   2163  f78b
   2164  f78b				   .L081		;  if ballx > player3x - 7  &&  ballx < player3x + 1  &&  bally > player3y - 7  &&  bally < player3y + 1 then i = 0  :  score = score + 10  :	soundb	=  50
   2165  f78b
   2166  f78b							; complex condition detected
   2167  f78b		       a5 87		      LDA	player3x
   2168  f78d		       38		      SEC
   2169  f78e		       e9 07		      SBC	#7
   2170  f790							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   2171  f790		       c5 82		      CMP	ballx
   2172  f792		       b0 42		      BCS	.skipL081
   2173  f794				   .condpart53
   2174  f794							; complex condition detected
   2175  f794		       a5 87		      LDA	player3x
   2176  f796		       18		      CLC
   2177  f797		       69 01		      ADC	#1
   2178  f799		       48		      PHA
   2179  f79a		       ba		      TSX
   2180  f79b		       68		      PLA
   2181  f79c		       a5 82		      LDA	ballx
   2182  f79e		       d5 01		      CMP	1,x
   2183  f7a0		       b0 34		      BCS	.skip53then
   2184  f7a2				   .condpart54
   2185  f7a2							; complex condition detected
   2186  f7a2		       a5 90		      LDA	player3y
   2187  f7a4		       38		      SEC
   2188  f7a5		       e9 07		      SBC	#7
   2189  f7a7							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   2190  f7a7		       c5 8c		      CMP	bally
   2191  f7a9		       b0 2b		      BCS	.skip54then
   2192  f7ab				   .condpart55
   2193  f7ab							; complex condition detected
   2194  f7ab		       a5 90		      LDA	player3y
   2195  f7ad		       18		      CLC
   2196  f7ae		       69 01		      ADC	#1
   2197  f7b0		       48		      PHA
   2198  f7b1		       ba		      TSX
   2199  f7b2		       68		      PLA
   2200  f7b3		       a5 8c		      LDA	bally
   2201  f7b5		       d5 01		      CMP	1,x
   2202  f7b7		       b0 1d		      BCS	.skip55then
   2203  f7b9				   .condpart56
   2204  f7b9		       a9 00		      LDA	#0
   2205  f7bb		       85 df		      STA	i
   2206  f7bd		       f8		      SED
   2207  f7be		       18		      CLC
   2208  f7bf		       a5 d4		      LDA	score+2
   2209  f7c1		       69 10		      ADC	#$10
   2210  f7c3		       85 d4		      STA	score+2
   2211  f7c5		       a5 d3		      LDA	score+1
   2212  f7c7		       69 00		      ADC	#$00
   2213  f7c9		       85 d3		      STA	score+1
   2214  f7cb		       a5 d2		      LDA	score
   2215  f7cd		       69 00		      ADC	#$00
   2216  f7cf		       85 d2		      STA	score
   2217  f7d1		       d8		      CLD
   2218  f7d2		       a9 32		      LDA	#50
   2219  f7d4		       85 e8		      STA	soundb
   2220  f7d6				   .skip55then
   2221  f7d6				   .skip54then
   2222  f7d6				   .skip53then
   2223  f7d6				   .skipL081
   2224  f7d6				   .L082		;  if i = 0 then player3x = 0	:  player3y = 0
   2225  f7d6
   2226  f7d6		       a5 df		      LDA	i
   2227  f7d8		       c9 00		      CMP	#0
   2228  f7da		       d0 06		      BNE	.skipL082
   2229  f7dc				   .condpart57
   2230  f7dc		       a9 00		      LDA	#0
   2231  f7de		       85 87		      STA	player3x
   2232  f7e0		       85 90		      STA	player3y
   2233  f7e2				   .skipL082
   2234  f7e2				   .
   2235  f7e2							; 
   2236  f7e2
   2237  f7e2				   .
   2238  f7e2							; 
   2239  f7e2
   2240  f7e2				   .L083		;  if j = 1 then player2x = player2x + 1
   2241  f7e2
   2242  f7e2		       a5 e0		      LDA	j
   2243  f7e4		       c9 01		      CMP	#1
   2244  f7e6		       d0 02		      BNE	.skipL083
   2245  f7e8				   .condpart58
   2246  f7e8		       e6 86		      INC	player2x
   2247  f7ea				   .skipL083
   2248  f7ea				   .L084		;  if j = 1  &&  player2x > 160 then player2x = 0  :  player2y  =   ( rand & 30 )  + 20
   2249  f7ea
   2250  f7ea		       a5 e0		      LDA	j
   2251  f7ec		       c9 01		      CMP	#1
   2252  f7ee		       d0 14		      BNE	.skipL084
   2253  f7f0				   .condpart59
   2254  f7f0		       a9 a0		      LDA	#160
   2255  f7f2		       c5 86		      CMP	player2x
   2256  f7f4		       b0 0e		      BCS	.skip59then
   2257  f7f6				   .condpart60
   2258  f7f6		       a9 00		      LDA	#0
   2259  f7f8		       85 86		      STA	player2x
   2260  f7fa							; complex statement detected
   2261  f7fa		       20 26 f4 	      jsr	randomize
   2262  f7fd		       29 1e		      AND	#30
   2263  f7ff		       18		      CLC
   2264  f800		       69 14		      ADC	#20
   2265  f802		       85 8f		      STA	player2y
   2266  f804				   .skip59then
   2267  f804				   .skipL084
   2268  f804				   .
   2269  f804							; 
   2270  f804
   2271  f804				   .L085		;  if ballx > player2x - 7  &&  ballx < player2x + 1  &&  bally > player2y - 7  &&  bally < player2y + 1 then j = 0  :  score = score + 10  :	soundb	=  50
   2272  f804
   2273  f804							; complex condition detected
   2274  f804		       a5 86		      LDA	player2x
   2275  f806		       38		      SEC
   2276  f807		       e9 07		      SBC	#7
   2277  f809							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   2278  f809		       c5 82		      CMP	ballx
   2279  f80b		       b0 42		      BCS	.skipL085
   2280  f80d				   .condpart61
   2281  f80d							; complex condition detected
   2282  f80d		       a5 86		      LDA	player2x
   2283  f80f		       18		      CLC
   2284  f810		       69 01		      ADC	#1
   2285  f812		       48		      PHA
   2286  f813		       ba		      TSX
   2287  f814		       68		      PLA
   2288  f815		       a5 82		      LDA	ballx
   2289  f817		       d5 01		      CMP	1,x
   2290  f819		       b0 34		      BCS	.skip61then
   2291  f81b				   .condpart62
   2292  f81b							; complex condition detected
   2293  f81b		       a5 8f		      LDA	player2y
   2294  f81d		       38		      SEC
   2295  f81e		       e9 07		      SBC	#7
   2296  f820							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   2297  f820		       c5 8c		      CMP	bally
   2298  f822		       b0 2b		      BCS	.skip62then
   2299  f824				   .condpart63
   2300  f824							; complex condition detected
   2301  f824		       a5 8f		      LDA	player2y
   2302  f826		       18		      CLC
   2303  f827		       69 01		      ADC	#1
   2304  f829		       48		      PHA
   2305  f82a		       ba		      TSX
   2306  f82b		       68		      PLA
   2307  f82c		       a5 8c		      LDA	bally
   2308  f82e		       d5 01		      CMP	1,x
   2309  f830		       b0 1d		      BCS	.skip63then
   2310  f832				   .condpart64
   2311  f832		       a9 00		      LDA	#0
   2312  f834		       85 e0		      STA	j
   2313  f836		       f8		      SED
   2314  f837		       18		      CLC
   2315  f838		       a5 d4		      LDA	score+2
   2316  f83a		       69 10		      ADC	#$10
   2317  f83c		       85 d4		      STA	score+2
   2318  f83e		       a5 d3		      LDA	score+1
   2319  f840		       69 00		      ADC	#$00
   2320  f842		       85 d3		      STA	score+1
   2321  f844		       a5 d2		      LDA	score
   2322  f846		       69 00		      ADC	#$00
   2323  f848		       85 d2		      STA	score
   2324  f84a		       d8		      CLD
   2325  f84b		       a9 32		      LDA	#50
   2326  f84d		       85 e8		      STA	soundb
   2327  f84f				   .skip63then
   2328  f84f				   .skip62then
   2329  f84f				   .skip61then
   2330  f84f				   .skipL085
   2331  f84f				   .
   2332  f84f							; 
   2333  f84f
   2334  f84f				   .L086		;  if j = 0 then player2x = 0	:  player2y = 0
   2335  f84f
   2336  f84f		       a5 e0		      LDA	j
   2337  f851		       c9 00		      CMP	#0
   2338  f853		       d0 06		      BNE	.skipL086
   2339  f855				   .condpart65
   2340  f855		       a9 00		      LDA	#0
   2341  f857		       85 86		      STA	player2x
   2342  f859		       85 8f		      STA	player2y
   2343  f85b				   .skipL086
   2344  f85b				   .
   2345  f85b							; 
   2346  f85b
   2347  f85b				   .L087		;  if soundb  >  0 then soundb  =  soundb  -  1  :  AUDC1  =  8  :  AUDV1  =  4  :  AUDF1  =  soundb else AUDV1  =  0
   2348  f85b
   2349  f85b		       a9 00		      LDA	#0
   2350  f85d		       c5 e8		      CMP	soundb
   2351  f85f		       b0 11		      BCS	.skipL087
   2352  f861				   .condpart66
   2353  f861		       c6 e8		      DEC	soundb
   2354  f863		       a9 08		      LDA	#8
   2355  f865		       85 16		      STA	AUDC1
   2356  f867		       a9 04		      LDA	#4
   2357  f869		       85 1a		      STA	AUDV1
   2358  f86b		       a5 e8		      LDA	soundb
   2359  f86d		       85 18		      STA	AUDF1
   2360  f86f		       4c 76 f8 	      jmp	.skipelse3
   2361  f872				   .skipL087
   2362  f872		       a9 00		      LDA	#0
   2363  f874		       85 1a		      STA	AUDV1
   2364  f876				   .skipelse3
   2365  f876				   .
   2366  f876							; 
   2367  f876
   2368  f876				   .L088		;  if x = 0 then x = 1
   2369  f876
   2370  f876		       a5 ee		      LDA	x
   2371  f878		       c9 00		      CMP	#0
   2372  f87a		       d0 04		      BNE	.skipL088
   2373  f87c				   .condpart67
   2374  f87c		       a9 01		      LDA	#1
   2375  f87e		       85 ee		      STA	x
   2376  f880				   .skipL088
   2377  f880				   .L089		;  if x > 160 - 7 then x = 160 - 7
   2378  f880
   2379  f880							; complex condition detected
   2380  f880		       a9 a0		      LDA	#160
   2381  f882		       38		      SEC
   2382  f883		       e9 07		      SBC	#7
   2383  f885		       c5 ee		      CMP	x
   2384  f887		       b0 07		      BCS	.skipL089
   2385  f889				   .condpart68
   2386  f889		       a9 a0		      LDA	#160
   2387  f88b		       38		      SEC
   2388  f88c		       e9 07		      SBC	#7
   2389  f88e		       85 ee		      STA	x
   2390  f890				   .skipL089
   2391  f890				   .
   2392  f890							; 
   2393  f890
   2394  f890				   .L090		;  if y < 9 then goto _ReiniciarNivel
   2395  f890
   2396  f890		       a5 ef		      LDA	y
   2397  f892		       c9 09		      CMP	#9
   2398  f894		       b0 03		      BCS	.skipL090
   2399  f896				   .condpart69
   2400  f896		       4c 30 f4 	      jmp	._ReiniciarNivel
   2401  f899
   2402  f899				   .skipL090
   2403  f899				   .
   2404  f899							; 
   2405  f899
   2406  f899				   .
   2407  f899							; 
   2408  f899
   2409  f899				   .L091		;  if f > 21 then f = 1
   2410  f899
   2411  f899		       a9 15		      LDA	#21
   2412  f89b		       c5 dc		      CMP	f
   2413  f89d		       b0 04		      BCS	.skipL091
   2414  f89f				   .condpart70
   2415  f89f		       a9 01		      LDA	#1
   2416  f8a1		       85 dc		      STA	f
   2417  f8a3				   .skipL091
   2418  f8a3				   .
   2419  f8a3							; 
   2420  f8a3
   2421  f8a3				   .L092		;  if i = 0  &&  j = 0 then n = 1  :  goto _ReiniciarNivel
   2422  f8a3
   2423  f8a3		       a5 df		      LDA	i
   2424  f8a5		       c9 00		      CMP	#0
   2425  f8a7		       d0 0d		      BNE	.skipL092
   2426  f8a9				   .condpart71
   2427  f8a9		       a5 e0		      LDA	j
   2428  f8ab		       c9 00		      CMP	#0
   2429  f8ad		       d0 07		      BNE	.skip71then
   2430  f8af				   .condpart72
   2431  f8af		       a9 01		      LDA	#1
   2432  f8b1		       85 e4		      STA	n
   2433  f8b3		       4c 30 f4 	      jmp	._ReiniciarNivel
   2434  f8b6
   2435  f8b6				   .skip71then
   2436  f8b6				   .skipL092
   2437  f8b6				   .
   2438  f8b6							; 
   2439  f8b6
   2440  f8b6				   .L093		;  goto main
   2441  f8b6
   2442  f8b6		       4c 88 f4 	      jmp	.main
   2443  f8b9
   2444  f8b9				   .
   2445  f8b9							; 
   2446  f8b9
   2447  f8b9				   .L094		;  inline pfread_msk.asm
------- FILE pfread_msk.asm LEVEL 2 PASS 2
      0  f8b9					      include	pfread_msk.asm
      1  f8b9							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f8b9
      3  f8b9				   pfread
      4  f8b9		       c9 10		      cmp	#16
      5  f8bb		       90 02		      bcc	lefthalf
      6  f8bd		       49 1f		      eor	#31	; 16-31 converted to 15-0
      7  f8bf				   lefthalf
      8  f8bf		       aa		      tax
      9  f8c0		       bd cd f8 	      lda	bytemask,x
     10  f8c3		       e0 08		      cpx	#8
     11  f8c5		       90 03		      bcc	bytedone
     12  f8c7		       31 bd		      and	(PF2pointer),y
     13  f8c9		       0c		      .byte.b	$0C
     14  f8ca				   bytedone
     15  f8ca		       31 bb		      and	(PF1pointer),y
      0  f8cc					      RETURN
      1  f8cc					      ifnconst	bankswitch
      2  f8cc		       60		      rts
      3  f8cd				  -	      else
      4  f8cd				  -	      jmp	BS_return
      5  f8cd					      endif
     17  f8cd				   bytemask
     18  f8cd		       80 40 20 10*	      .byte.b	$80,$40,$20,$10,8,4,2,1
     19  f8d5		       01 02 04 08*	      .byte.b	1,2,4,8,$10,$20,$40,$80
------- FILE C:\Atari2600\bB\samples\Ejemplo.bas.asm
   2449  f8dd				  -	      if	(<*) > (<(*+8))
   2450  f8dd				  -	      repeat	($100-<*)
   2451  f8dd				  -	      .byte	0
   2452  f8dd				  -	      repend
   2453  f8dd					      endif
   2454  f8dd				  -	      if	(<*) < 90
   2455  f8dd				  -	      repeat	(90-<*)
   2456  f8dd				  -	      .byte	0
   2457  f8dd				  -	      repend
   2458  f8dd					      endif
   2459  f8dd				   player3then_0
   2460  f8dd		       00		      .byte.b	0
   2461  f8de		       e7		      .byte.b	%11100111
   2462  f8df		       24		      .byte.b	%00100100
   2463  f8e0		       18		      .byte.b	%00011000
   2464  f8e1		       5a		      .byte.b	%01011010
   2465  f8e2		       3c		      .byte.b	%00111100
   2466  f8e3		       18		      .byte.b	%00011000
   2467  f8e4		       24		      .byte.b	%00100100
   2468  f8e5		       3c		      .byte.b	%00111100
   2469  f8e6				  -	      if	(<*) > (<(*+9))
   2470  f8e6				  -	      repeat	($100-<*)
   2471  f8e6				  -	      .byte	0
   2472  f8e6				  -	      repend
   2473  f8e6					      endif
   2474  f8e6				  -	      if	(<*) < 90
   2475  f8e6				  -	      repeat	(90-<*)
   2476  f8e6				  -	      .byte	0
   2477  f8e6				  -	      repend
   2478  f8e6					      endif
   2479  f8e6				   player4then_0
   2480  f8e6		       00		      .byte.b	0
   2481  f8e7		       c0		      .byte.b	%11000000
   2482  f8e8		       66		      .byte.b	%01100110
   2483  f8e9		       25		      .byte.b	%00100101
   2484  f8ea		       58		      .byte.b	%01011000
   2485  f8eb		       58		      .byte.b	%01011000
   2486  f8ec		       3e		      .byte.b	%00111110
   2487  f8ed		       18		      .byte.b	%00011000
   2488  f8ee		       24		      .byte.b	%00100100
   2489  f8ef		       3c		      .byte.b	%00111100
   2490  f8f0				  -	      if	(<*) > (<(*+7))
   2491  f8f0				  -	      repeat	($100-<*)
   2492  f8f0				  -	      .byte	0
   2493  f8f0				  -	      repend
   2494  f8f0					      endif
   2495  f8f0				  -	      if	(<*) < 90
   2496  f8f0				  -	      repeat	(90-<*)
   2497  f8f0				  -	      .byte	0
   2498  f8f0				  -	      repend
   2499  f8f0					      endif
   2500  f8f0				   playerL022_3
   2501  f8f0		       ff		      .byte.b	%11111111
   2502  f8f1		       ff		      .byte.b	%11111111
   2503  f8f2		       ff		      .byte.b	%11111111
   2504  f8f3		       ff		      .byte.b	%11111111
   2505  f8f4		       ff		      .byte.b	%11111111
   2506  f8f5		       ff		      .byte.b	%11111111
   2507  f8f6		       ff		      .byte.b	%11111111
   2508  f8f7		       ff		      .byte.b	%11111111
   2509  f8f8				  -	      if	(<*) > (<(*+7))
   2510  f8f8				  -	      repeat	($100-<*)
   2511  f8f8				  -	      .byte	0
   2512  f8f8				  -	      repend
   2513  f8f8					      endif
   2514  f8f8				  -	      if	(<*) < 90
   2515  f8f8				  -	      repeat	(90-<*)
   2516  f8f8				  -	      .byte	0
   2517  f8f8				  -	      repend
   2518  f8f8					      endif
   2519  f8f8				   playerL023_2
   2520  f8f8		       ff		      .byte.b	%11111111
   2521  f8f9		       81		      .byte.b	%10000001
   2522  f8fa		       ff		      .byte.b	%11111111
   2523  f8fb		       ff		      .byte.b	%11111111
   2524  f8fc		       ff		      .byte.b	%11111111
   2525  f8fd		       ff		      .byte.b	%11111111
   2526  f8fe		       81		      .byte.b	%10000001
   2527  f8ff		       ff		      .byte.b	%11111111
   2528  f900				  -	      if	((>(*+11)) > (>*))
   2529  f900				  -	      ALIGN	256
   2530  f900					      endif
   2531  f900				   PF1_data0
   2532  f900		       00		      .byte.b	%00000000
   2533  f901		       07		      .byte.b	%00000111
   2534  f902		       00		      .byte.b	%00000000
   2535  f903		       00		      .byte.b	%00000000
   2536  f904		       00		      .byte.b	%00000000
   2537  f905		       00		      .byte.b	%00000000
   2538  f906		       00		      .byte.b	%00000000
   2539  f907		       00		      .byte.b	%00000000
   2540  f908		       00		      .byte.b	%00000000
   2541  f909		       00		      .byte.b	%00000000
   2542  f90a		       00		      .byte.b	%00000000
   2543  f90b				  -	      if	((>(*+11)) > (>*))
   2544  f90b				  -	      ALIGN	256
   2545  f90b					      endif
   2546  f90b				   PF2_data0
   2547  f90b		       00		      .byte.b	%00000000
   2548  f90c		       ff		      .byte.b	%11111111
   2549  f90d		       00		      .byte.b	%00000000
   2550  f90e		       00		      .byte.b	%00000000
   2551  f90f		       00		      .byte.b	%00000000
   2552  f910		       1f		      .byte.b	%00011111
   2553  f911		       00		      .byte.b	%00000000
   2554  f912		       00		      .byte.b	%00000000
   2555  f913		       00		      .byte.b	%00000000
   2556  f914		       00		      .byte.b	%00000000
   2557  f915		       00		      .byte.b	%00000000
   2558  f916				  -	      if	((>(*+11)) > (>*))
   2559  f916				  -	      ALIGN	256
   2560  f916					      endif
   2561  f916				   PF1_data1
   2562  f916		       00		      .byte.b	%00000000
   2563  f917		       00		      .byte.b	%00000000
   2564  f918		       00		      .byte.b	%00000000
   2565  f919		       ff		      .byte.b	%11111111
   2566  f91a		       00		      .byte.b	%00000000
   2567  f91b		       00		      .byte.b	%00000000
   2568  f91c		       00		      .byte.b	%00000000
   2569  f91d		       00		      .byte.b	%00000000
   2570  f91e		       00		      .byte.b	%00000000
   2571  f91f		       00		      .byte.b	%00000000
   2572  f920		       00		      .byte.b	%00000000
   2573  f921				  -	      if	((>(*+11)) > (>*))
   2574  f921				  -	      ALIGN	256
   2575  f921					      endif
   2576  f921				   PF2_data1
   2577  f921		       00		      .byte.b	%00000000
   2578  f922		       00		      .byte.b	%00000000
   2579  f923		       00		      .byte.b	%00000000
   2580  f924		       7f		      .byte.b	%01111111
   2581  f925		       00		      .byte.b	%00000000
   2582  f926		       00		      .byte.b	%00000000
   2583  f927		       e0		      .byte.b	%11100000
   2584  f928		       00		      .byte.b	%00000000
   2585  f929		       00		      .byte.b	%00000000
   2586  f92a		       00		      .byte.b	%00000000
   2587  f92b		       00		      .byte.b	%00000000
   2588  f92c					      if	ECHOFIRST
      1648 bytes of ROM space left
   2589  f92c					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left")
   2590  f92c					      endif
   2591  f92c		       00 01	   ECHOFIRST  =	1
   2592  f92c
   2593  f92c
   2594  f92c
   2595  f92c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2596  f92c
   2597  f92c							; feel free to modify the score graphics - just keep each digit 8 high
   2598  f92c							; and keep the conditional compilation stuff intact
   2599  f92c				  -	      ifconst	ROM2k
   2600  f92c				  -	      ORG	$F7AC-8
   2601  f92c					      else
   2602  f92c				  -	      ifconst	bankswitch
   2603  f92c				  -	      if	bankswitch == 8
   2604  f92c				  -	      ORG	$2F94-bscode_length
   2605  f92c				  -	      RORG	$FF94-bscode_length
   2606  f92c				  -	      endif
   2607  f92c				  -	      if	bankswitch == 16
   2608  f92c				  -	      ORG	$4F94-bscode_length
   2609  f92c				  -	      RORG	$FF94-bscode_length
   2610  f92c				  -	      endif
   2611  f92c				  -	      if	bankswitch == 32
   2612  f92c				  -	      ORG	$8F94-bscode_length
   2613  f92c				  -	      RORG	$FF94-bscode_length
   2614  f92c				  -	      endif
   2615  f92c				  -	      if	bankswitch == 64
   2616  f92c				  -	      ORG	$10F80-bscode_length
   2617  f92c				  -	      RORG	$1FF80-bscode_length
   2618  f92c				  -	      endif
   2619  f92c					      else
   2620  ff9c					      ORG	$FF9C
   2621  ff9c					      endif
   2622  ff9c					      endif
   2623  ff9c
   2624  ff9c							; font equates
   2625  ff9c		       00 01	   .21stcentury =	1
   2626  ff9c		       00 02	   alarmclock =	2
   2627  ff9c		       00 03	   handwritten =	3
   2628  ff9c		       00 04	   interrupted =	4
   2629  ff9c		       00 05	   retroputer =	5
   2630  ff9c		       00 06	   whimsey    =	6
   2631  ff9c		       00 07	   tiny       =	7
   2632  ff9c		       00 08	   hex	      =	8
   2633  ff9c
   2634  ff9c				  -	      ifconst	font
   2635  ff9c				  -	      if	font == hex
   2636  ff9c				  -	      ORG	. - 48
   2637  ff9c				  -	      endif
   2638  ff9c					      endif
   2639  ff9c
   2640  ff9c				   scoretable
   2641  ff9c
   2642  ff9c				  -	      ifconst	font
   2643  ff9c				  -	      if	font == .21stcentury
   2644  ff9c				  -	      include	"score_graphics.asm.21stcentury"
   2645  ff9c				  -	      endif
   2646  ff9c				  -	      if	font == alarmclock
   2647  ff9c				  -	      include	"score_graphics.asm.alarmclock"
   2648  ff9c				  -	      endif
   2649  ff9c				  -	      if	font == handwritten
   2650  ff9c				  -	      include	"score_graphics.asm.handwritten"
   2651  ff9c				  -	      endif
   2652  ff9c				  -	      if	font == interrupted
   2653  ff9c				  -	      include	"score_graphics.asm.interrupted"
   2654  ff9c				  -	      endif
   2655  ff9c				  -	      if	font == retroputer
   2656  ff9c				  -	      include	"score_graphics.asm.retroputer"
   2657  ff9c				  -	      endif
   2658  ff9c				  -	      if	font == whimsey
   2659  ff9c				  -	      include	"score_graphics.asm.whimsey"
   2660  ff9c				  -	      endif
   2661  ff9c				  -	      if	font == tiny
   2662  ff9c				  -	      include	"score_graphics.asm.tiny"
   2663  ff9c				  -	      endif
   2664  ff9c				  -	      if	font == hex
   2665  ff9c				  -	      include	"score_graphics.asm.hex"
   2666  ff9c				  -	      endif
   2667  ff9c					      else		; default font
   2668  ff9c
   2669  ff9c		       3c		      .byte.b	%00111100
   2670  ff9d		       66		      .byte.b	%01100110
   2671  ff9e		       66		      .byte.b	%01100110
   2672  ff9f		       66		      .byte.b	%01100110
   2673  ffa0		       66		      .byte.b	%01100110
   2674  ffa1		       66		      .byte.b	%01100110
   2675  ffa2		       66		      .byte.b	%01100110
   2676  ffa3		       3c		      .byte.b	%00111100
   2677  ffa4
   2678  ffa4		       7e		      .byte.b	%01111110
   2679  ffa5		       18		      .byte.b	%00011000
   2680  ffa6		       18		      .byte.b	%00011000
   2681  ffa7		       18		      .byte.b	%00011000
   2682  ffa8		       18		      .byte.b	%00011000
   2683  ffa9		       38		      .byte.b	%00111000
   2684  ffaa		       18		      .byte.b	%00011000
   2685  ffab		       08		      .byte.b	%00001000
   2686  ffac
   2687  ffac		       7e		      .byte.b	%01111110
   2688  ffad		       60		      .byte.b	%01100000
   2689  ffae		       60		      .byte.b	%01100000
   2690  ffaf		       3c		      .byte.b	%00111100
   2691  ffb0		       06		      .byte.b	%00000110
   2692  ffb1		       06		      .byte.b	%00000110
   2693  ffb2		       46		      .byte.b	%01000110
   2694  ffb3		       3c		      .byte.b	%00111100
   2695  ffb4
   2696  ffb4		       3c		      .byte.b	%00111100
   2697  ffb5		       46		      .byte.b	%01000110
   2698  ffb6		       06		      .byte.b	%00000110
   2699  ffb7		       06		      .byte.b	%00000110
   2700  ffb8		       1c		      .byte.b	%00011100
   2701  ffb9		       06		      .byte.b	%00000110
   2702  ffba		       46		      .byte.b	%01000110
   2703  ffbb		       3c		      .byte.b	%00111100
   2704  ffbc
   2705  ffbc		       0c		      .byte.b	%00001100
   2706  ffbd		       0c		      .byte.b	%00001100
   2707  ffbe		       7e		      .byte.b	%01111110
   2708  ffbf		       4c		      .byte.b	%01001100
   2709  ffc0		       4c		      .byte.b	%01001100
   2710  ffc1		       2c		      .byte.b	%00101100
   2711  ffc2		       1c		      .byte.b	%00011100
   2712  ffc3		       0c		      .byte.b	%00001100
   2713  ffc4
   2714  ffc4		       3c		      .byte.b	%00111100
   2715  ffc5		       46		      .byte.b	%01000110
   2716  ffc6		       06		      .byte.b	%00000110
   2717  ffc7		       06		      .byte.b	%00000110
   2718  ffc8		       3c		      .byte.b	%00111100
   2719  ffc9		       60		      .byte.b	%01100000
   2720  ffca		       60		      .byte.b	%01100000
   2721  ffcb		       7e		      .byte.b	%01111110
   2722  ffcc
   2723  ffcc		       3c		      .byte.b	%00111100
   2724  ffcd		       66		      .byte.b	%01100110
   2725  ffce		       66		      .byte.b	%01100110
   2726  ffcf		       66		      .byte.b	%01100110
   2727  ffd0		       7c		      .byte.b	%01111100
   2728  ffd1		       60		      .byte.b	%01100000
   2729  ffd2		       62		      .byte.b	%01100010
   2730  ffd3		       3c		      .byte.b	%00111100
   2731  ffd4
   2732  ffd4		       30		      .byte.b	%00110000
   2733  ffd5		       30		      .byte.b	%00110000
   2734  ffd6		       30		      .byte.b	%00110000
   2735  ffd7		       18		      .byte.b	%00011000
   2736  ffd8		       0c		      .byte.b	%00001100
   2737  ffd9		       06		      .byte.b	%00000110
   2738  ffda		       42		      .byte.b	%01000010
   2739  ffdb		       3e		      .byte.b	%00111110
   2740  ffdc
   2741  ffdc		       3c		      .byte.b	%00111100
   2742  ffdd		       66		      .byte.b	%01100110
   2743  ffde		       66		      .byte.b	%01100110
   2744  ffdf		       66		      .byte.b	%01100110
   2745  ffe0		       3c		      .byte.b	%00111100
   2746  ffe1		       66		      .byte.b	%01100110
   2747  ffe2		       66		      .byte.b	%01100110
   2748  ffe3		       3c		      .byte.b	%00111100
   2749  ffe4
   2750  ffe4		       3c		      .byte.b	%00111100
   2751  ffe5		       46		      .byte.b	%01000110
   2752  ffe6		       06		      .byte.b	%00000110
   2753  ffe7		       3e		      .byte.b	%00111110
   2754  ffe8		       66		      .byte.b	%01100110
   2755  ffe9		       66		      .byte.b	%01100110
   2756  ffea		       66		      .byte.b	%01100110
   2757  ffeb		       3c		      .byte.b	%00111100
   2758  ffec
   2759  ffec					      ifnconst	DPC_kernel_options
   2760  ffec
   2761  ffec		       00		      .byte.b	%00000000
   2762  ffed		       00		      .byte.b	%00000000
   2763  ffee		       00		      .byte.b	%00000000
   2764  ffef		       00		      .byte.b	%00000000
   2765  fff0		       00		      .byte.b	%00000000
   2766  fff1		       00		      .byte.b	%00000000
   2767  fff2		       00		      .byte.b	%00000000
   2768  fff3		       00		      .byte.b	%00000000
   2769  fff4
   2770  fff4					      endif
   2771  fff4
   2772  fff4					      endif
   2773  fff4
   2774  fff4				  -	      ifconst	ROM2k
   2775  fff4				  -	      ORG	$F7FC
   2776  fff4					      else
   2777  fff4				  -	      ifconst	bankswitch
   2778  fff4				  -	      if	bankswitch == 8
   2779  fff4				  -	      ORG	$2FF4-bscode_length
   2780  fff4				  -	      RORG	$FFF4-bscode_length
   2781  fff4				  -	      endif
   2782  fff4				  -	      if	bankswitch == 16
   2783  fff4				  -	      ORG	$4FF4-bscode_length
   2784  fff4				  -	      RORG	$FFF4-bscode_length
   2785  fff4				  -	      endif
   2786  fff4				  -	      if	bankswitch == 32
   2787  fff4				  -	      ORG	$8FF4-bscode_length
   2788  fff4				  -	      RORG	$FFF4-bscode_length
   2789  fff4				  -	      endif
   2790  fff4				  -	      if	bankswitch == 64
   2791  fff4				  -	      ORG	$10FE0-bscode_length
   2792  fff4				  -	      RORG	$1FFE0-bscode_length
   2793  fff4				  -	      endif
   2794  fff4					      else
   2795  fffc					      ORG	$FFFC
   2796  fffc					      endif
   2797  fffc					      endif
   2798  fffc							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2799  fffc
   2800  fffc				  -	      ifconst	bankswitch
   2801  fffc				  -	      if	bankswitch == 8
   2802  fffc				  -	      ORG	$2FFC
   2803  fffc				  -	      RORG	$FFFC
   2804  fffc				  -	      endif
   2805  fffc				  -	      if	bankswitch == 16
   2806  fffc				  -	      ORG	$4FFC
   2807  fffc				  -	      RORG	$FFFC
   2808  fffc				  -	      endif
   2809  fffc				  -	      if	bankswitch == 32
   2810  fffc				  -	      ORG	$8FFC
   2811  fffc				  -	      RORG	$FFFC
   2812  fffc				  -	      endif
   2813  fffc				  -	      if	bankswitch == 64
   2814  fffc				  -	      ORG	$10FF0
   2815  fffc				  -	      RORG	$1FFF0
   2816  fffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   2817  fffc				  -	      ORG	$10FF8
   2818  fffc				  -	      RORG	$1FFF8
   2819  fffc				  -	      ifconst	superchip
   2820  fffc				  -	      .byte	"E","F","S","C"
   2821  fffc				  -	      else
   2822  fffc				  -	      .byte	"E","F","E","F"
   2823  fffc				  -	      endif
   2824  fffc				  -	      ORG	$10FFC
   2825  fffc				  -	      RORG	$1FFFC
   2826  fffc				  -	      endif
   2827  fffc					      else
   2828  fffc				  -	      ifconst	ROM2k
   2829  fffc				  -	      ORG	$F7FC
   2830  fffc					      else
   2831  fffc					      ORG	$FFFC
   2832  fffc					      endif
   2833  fffc					      endif
   2834  fffc		       f3 f3		      .word.w	(start & $ffff)
   2835  fffe		       f3 f3		      .word.w	(start & $ffff)
